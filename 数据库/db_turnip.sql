/*
SQLyog 企业版 - MySQL GUI v8.14 
MySQL - 5.7.22-log : Database - db_turnip
*********************************************************************
*/

/*!40101 SET NAMES utf8 */;

/*!40101 SET SQL_MODE=''*/;

/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
CREATE DATABASE /*!32312 IF NOT EXISTS*/`db_turnip` /*!40100 DEFAULT CHARACTER SET utf8 */;

USE `db_turnip`;

/*Table structure for table `t_article` */

DROP TABLE IF EXISTS `t_article`;

CREATE TABLE `t_article` (
  `t_id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '文章id',
  `t_picture` varchar(255) DEFAULT './T_Image/articleImg/default.jpeg' COMMENT '文章配图',
  `t_headline` varchar(100) NOT NULL COMMENT '文章标题',
  `t_content` text NOT NULL COMMENT '文章内容',
  `t_text` text COMMENT '文章主要内容',
  `t_tag` varchar(20) NOT NULL DEFAULT '学习' COMMENT '文章标签',
  `t_route` varchar(20) NOT NULL COMMENT '文章路由',
  `t_date` datetime DEFAULT NULL COMMENT '写作时间',
  `t_textNumber` varchar(100) DEFAULT NULL COMMENT '文章字数',
  `t_liveNumber` varchar(20) DEFAULT '0' COMMENT '点赞数',
  `t_readNumber` varchar(20) DEFAULT '0' COMMENT '阅读数',
  `t_reviewNumber` varchar(20) DEFAULT '0' COMMENT '评论数',
  `t_writingPlatform` varchar(20) DEFAULT 'windows' COMMENT '写作平台',
  `t_browser` varchar(20) DEFAULT '火狐' COMMENT '浏览器',
  `t_key` int(10) unsigned NOT NULL DEFAULT '1' COMMENT '外键',
  PRIMARY KEY (`t_id`),
  KEY `t_key` (`t_key`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;

/*Data for the table `t_article` */

insert  into `t_article`(`t_id`,`t_picture`,`t_headline`,`t_content`,`t_text`,`t_tag`,`t_route`,`t_date`,`t_textNumber`,`t_liveNumber`,`t_readNumber`,`t_reviewNumber`,`t_writingPlatform`,`t_browser`,`t_key`) values (1,'./T_Image/articleImg/default.jpeg','第一篇--为什么会要做这个博客网站？','<h2 style=\"text-align:center;\" id=\"aprro\">第一篇：为什么会要做这个博客网站？</h2><p style=\"text-align:left\">&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color: rgb(194, 79, 74);\">一次偶然，我发现很多前端，亦或是后端的大学生均建有自己的网站，离谱的是非计算专业的大学生也有，甚至连正在上中学的学生也有。这让我羡慕也让我吃惊，也因此让我也萌生了建网站的想法。</span></p><hr/><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是，也刚好是我学完node.js、Vue.js的时候，大致了解了网站的流程。说干就干，我大致看了他们的网站，大都是使用的UI库。我本想也使用UI库，这样也更快，更好看。但细想下来，这么做对我的技术并不会有什么增长，因此，我决定尽量使用原生的web三剑客去实现我网站的特效、功能。至此，网站的主要功能（<span style=\"background-color: rgb(238, 236, 224);\">文章的编辑后，立即自动化渲染及生成对应路由</span>）已完成。很多并不太重要的功能，我并不准备立即完成。我深知自己的技术功底并不扎实，如这次建站并没有对许多API进行兼容性处理、写的代码很多没有考虑性能问题、代码没有进行压缩等，这些问题我会在未来几天着手优化、解决。也因此网站的后续功能只会缓慢更新，当然，还有就是有很多书需要看，及我也正在准备计算机二级考试和英语四级考试。</p><p><br/></p><p><br/></p><p style=\"text-align:right;\"><u>作者：turnip</u></p><p style=\"text-align:right;\"><i>2021年7月31日</i></p><p style=\"text-align:right;\"><i><br/></i></p><p style=\"text-align:right;\"><i><br/></i></p>','一次偶然，我发现很多前端，亦或是后端的大学生均建有自己的网站，离谱的是非计算专业的大学生也有，甚至连正在上中学的学生也有。这让我羡慕也让我吃惊，也因此让我也萌生了建网站的想法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是，也刚好是我学完node.js、Vue.js的时候，大致了解了网站的流程。说干就干，我大致看了他们的网站，大都是使用的UI库。我本想也使用UI库，这样也更快，更好看。但细想下来，这么做对我的技术并不会有什么增长，因此，我决定尽量使用原生的web三剑客去实现我网站的特效、功能。至此，网站的主要功能（文章的编辑后，立即自动化渲染及生成对应路由）已完成。很多并不太重要的功能，我并不准备立即完成。我深知自己的技术功底并不扎实，如这次建站并没有对许多API进行兼容性处理、写的代码很多没有考虑性能问题、代码没有进行压缩等，这些问题我会在未来几天着手优化、解决。也因此网站的后续功能只会缓慢更新，当然，还有就是有很多书需要看，及我也正在准备计算机二级考试和英语四级考试。作者：turnip2021年7月31日','关于网站','/page1','2021-07-31 14:27:27','548','0','103','0','Windows','Edge',1),(2,'./T_Image/articleImg/hzw2.jpeg','第二篇--js的作用域和查询规则解析','<h1 id=\"x4m5c\" style=\"text-align:center;\">第二篇--js的作用域和查询规则解析</h1><p><strong>JavaScript中的作用域是词法作用域，即js引擎的查找规则，遵循代码书写时的作用气泡进行逐级查找。</strong></p><p><strong>这里简述一下LHS查询和RHS查询，即查询词法作用域内赋值操作的左右。详解左转<a href=\"https://blog.csdn.net/qq_26244513/article/details/118088162?spm=1001.2014.3001.5501\">你不知道的JavaScript知识梳理</a></strong></p><p><strong>下面解释一下词法作用域的逻辑</strong></p><p>注意：词法作用域是js引擎查找当前代码片段之前的作用域，请看代码</p><p>\n</p><pre><code class=\"JavaScript\">       <span class=\"hljs-built_in\">console</span>.log(a); <span class=\"hljs-regexp\">//</span><span class=\"hljs-literal\">undefined</span>\n        <span class=\"hljs-reserved\">var</span> a = <span class=\"hljs-number\">3</span>;</code></pre><p>\n\n\n\n\n\n\n\n\n</p><p>此时输出undefined，变量a变量提升到了console.log()之前，当console.log()执行时进行RHS查询，但此时a的赋值操作还未执行到，a的值还没进入到词法作用域内，故此时RHS查询得不到a的值，会输出undefined。</p><p>进而解释，请看代码</p><p>\n</p><p>\n\n\n\n\n\n\n</p><pre><code class=\"JavaScript\">       <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">bar</span><span class=\"hljs-params\">()</span> {</span>\n            console.log(a); <span class=\"hljs-comment\">//3</span>\n        }\n        <span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">3</span>;\n        bar();</code></pre><p>bar()在执行时，a的定义和赋值操作均已执行到，此时a已全部进入到词法作用域，故当函数调用，并执行函数内部的console.log()时，js引擎在其内部进行RHS查询得到了a的值。</p><p><strong>总结：词法作用域就是js引擎在代码逐行编译是各代码词法产生的作用域，故随着代码的编译作用域内部逐渐放大</strong></p><p>\n\n\n\n\n<br/></p>','JavaScript中的作用域是词法作用域，即js引擎的查找规则，遵循代码书写时的作用气泡进行逐级查找。这里简述一下LHS查询和RHS查询，即查询词法作用域内赋值操作的左右。详解左转你不知道的JavaScript知识梳理下面解释一下词法作用域的逻辑注意：词法作用域是js引擎查找当前代码片段之前的作用域，请看代码       console.log(a); //undefinedvar a = 3;此时输出undefined，变量a变量提升到了console.log()之前，当console.log()执行时进行RHS查询，但此时a的赋值操作还未执行到，a的值还没进入到词法作用域内，故此时RHS查询得不到a的值，会输出undefined。进而解释，请看代码       function bar() {//3var a = 3bar()在执行时，a的定义和赋值操作均已执行到，此时a已全部进入到词法作用域，故当函数调用，并执行函数内部的console.log()时，js引擎在其内部进行RHS查询得到了a的值。总结：词法作用域就是js引擎在代码逐行编译是各代码词法产生的作用域，故随着代码的编译作用域内部逐渐放大','JavaScript','/page2','2021-08-02 19:08:54','527','0','31','0','Windows','Edge',1),(3,'./T_Image/articleImg/default.jpeg','第三篇--你不知道的javascript知识梳理','<h1 style=\"text-align:center;\" id=\"lblpi\"><a href=\"https://blog.csdn.net/qq_26244513/article/details/118088162?spm=1001.2014.3001.5501\" target=\"_blank\">你不知道的JavaScript 上卷 知识梳</a></h1><p>完结语：2021年7月2日，终于写完了。我原本是想用一周的时间看完这本上卷的，也是没想到前前后后竟然花了十多天的时间。还好，收获还是挺多的，书中的内容的确让我对JavaScript这门语言有了更深的认识。<br/><br/>这个知识梳理适合那些已经看完了《你不知道的JavaScript&nbsp;上卷》，但仍觉得一头雾水的人，我也看了很多博主写了这本书的知识梳理，大都是对书中内容的简单堆砌，及简单的加以说明，这让我这个JavaScript小白在理解书中的概念时总是一头雾水，可能是初学的原因，我看到书中很多概念的时候，就像学了一个数学定理，也知道这个定理的意思，但是却不知道这个数学定理怎么使用，也无从知道书中表达的意思，故在数学学习的过程中我经常渴望知道别人的理解。因此，我决定自己写一篇《你不知道的JavaScript》知识梳理，认真揣摩作者的意思，以便更通俗的理解书中概念，尽量领会书中的每一章要表达什么。这本书看的较为仓促。若有错误，望评论区指正，我会仔细查阅资料并给予修改。<br/><br/>再过不久，我便会看剩下的两本书，我也会在博客里写出我的理解，希望看客们可以关注我，并可以给我一些指正。<br/><br/>第一部分&nbsp; 作用域和闭包<br/>第1章&nbsp; 作用域是什么<br/>我觉得本章的难点：<br/><br/>先来回答本章的标题：<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作用域是什么？<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作用域就是变量和函数的可访问范围，控制着变量和函数的可见性与生命周期。使用数学中的函数理解，说白了作用域就是取值范围。<br/><br/>        function　 foo(a) {<br/>            console.log(a); //2<br/>        };<br/>        foo(2);<br/><br/>上述代码是引擎和作用域的对话。这里注意，&nbsp;LHS和RHS是对于赋值操作( foo()函数的执行也可以理解为赋值操作，相当于是将一个函数赋值给foo，然后执行foo)，即赋值操作左边是否有我们要存放的容器，赋值操作右边是否有我们操作的值<br/><br/>即LHS查询：<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行foo()时，对foo的查询（是一个函数）<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;执行foo(2)时，对foo内的a进行查询（a是参数）<br/><br/>RHS查询：<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 执行foo(2)时，对a的赋值操作<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 执行console.log()时，对log()方法的引用<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 执行console.log(a)时，对a赋值的操作<br/><br/>由上述我们可以理解：为什么RHS查询会出现两种错误ReferenceError和TypeError了<br/><br/>前者是因为找不到赋值操作，后者是因为找到了，但是进行了不合理的操作，例如这样<br/><br/>   let foo = null;<br/>        foo(2);<br/>&nbsp;因此，我觉得TypeError错误可以理解为RHS查询成功了，但是进行了非法操作。当然这些书中提到了，我这里是梳理了一边逻辑。<br/><br/>这是小测验的代码，看完书里的解释，又理解了上面的内容，这个小测验就是小菜一碟<br/><br/>        function foo (a){<br/>            var b = a;<br/>            return a + b;<br/>        };<br/>        var c = foo( 2 );<br/>LHS查询：即赋值操作左边的容器。RHS查询：即赋值操作右边的值。<br/><br/>LHS：c=，a=2（foo(2)的隐式操作，就是找有没有a这个参数，因为即便函数有形参也可以不写实参），b=<br/><br/>其实我困惑在为什么a=2的赋值操作右边的=2不定义为RHS查询；我这里猜一下，是因为=2不用查，因为2本身就是值，查询的实质是找，变量是存储数据的容器，因此才需要找。<br/><br/>RHS：foo这个函数，=a，return a+b的a和b(return相当于是一个赋值操作a+b是赋值操作的值)，<br/><br/>本章重要知识：<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 1.JavaScript是编译语言，其编译发生在代码执行前的几微妙。即编译和执行几乎同步。因此JavaScript会用尽各种办法进行性能性能优化。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 2.引擎、编译器、作用域。简单了解作用即可。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 3.LHS和RHS查询<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 4.作用域嵌套：即在嵌套的作用域中，引擎的LHS查询会实行冒泡规则查找<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 5.不成功的LHS查找会自动创建一个全局变量（非严格模式），严格模式下会抛出ReferenceError异常，不成功的RHS查询会抛出ReferenceError异常<br/><br/>第2章&nbsp;词法作用域<br/>我认为本章的难点：<br/><br/>先通俗回答本章的标题：<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 词法作用域：即是语言给代码的书写提供了一套书写规则，按照这个规则而形成的作用域就是词法作用域，说白了就是代码块的作用范围。例如书写函数时，函数内部的数据，外部一般无法访问，这个函数作用范围就是词法作用域的一部分。<br/><br/><br/><br/>&nbsp;在这张图中，这三个作用域气泡就是词法作用域，即是按照代码的书写规则来，形成的代码块的作用范围。<br/><br/>作用域气泡严格包含，即只会出现气泡包含，不会出现气泡交叉<br/><br/>解释一下书中附录A中提到的动态作用域<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 1.JavaScript只有词法作用域！（但this机制和动态作用域很像）<br/><br/>        function foo() {<br/>            console.log(this.a); //2<br/>            console.log(a); //2<br/>        }<br/>        function bar() {<br/>            var a = 3;<br/>            foo();<br/>        }<br/>        var a = 2;<br/>        bar();<br/>&nbsp;这里如果JavaScript是动态作用域，那么输出的将会是3，因为动态作用域会查找调用栈。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 2.词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定的。<br/><br/>关于eval欺骗词法详解<br/><br/>        //eval欺骗词法<br/>        function foo(str, a) {<br/>            eval(str); //欺骗<br/>            console.log(a, b);<br/>        }<br/>        var b = 2;<br/>        foo(\'var b = 3;\', 1)<br/>&nbsp;基本上没啥好说的，就是会直接把传入的字符串转换为js代码，即此时的eval(str)完全等价于var b = 3;<br/><br/>说一下这个函数的妙用，eval会执行字符串，当我们的到的数据是可以执行的字符串时，那么使用eval还是挺炫的。<br/><br/>关于with欺骗词法的详解<br/><br/>先说理解，with会关联一个对象，并且with内的变量均会映射到关联对象的同名属性。with内的变量若没有映射到同名属性，则会LHS查询向上冒泡<br/><br/>        function foo(obj) {<br/>            with(obj) { //会创建作用域气泡<br/>                var b = 3; //实际上会被定义在foo函数内<br/>                // let c = 6;//会被限制在with内<br/>                a = 2; //这个a会直接找obj的属性a<br/>                console.log(a); //2<br/>                console.log(obj.a); //undefined<br/>                console.log(b); //3<br/>                console.log(obj.b); //undefined<br/>            };<br/>            // console.log(a) //ReferenceError<br/>            console.log(b); //3<br/>            // console.log(c);<br/>        };<br/>        var o1 = {<br/>            a: 3<br/>        }<br/>        var o2 = {<br/>            b: 3<br/>        };<br/>        foo(o1);<br/>        console.log(o1.a); //2<br/>        // // console.log(a); //RHS查询，ReferenceError<br/><br/>        // foo(o2);<br/>        // console.log(o2.a); //undefined<br/>        // console.log(o2.b); //undefined<br/>        // console.log(a); //2,window.a<br/>&nbsp;1.这句话的前半句就是说with会创建一个作用域气泡；后半句就是说传入对象的属性会关联到with作用域气泡内的同名标识符。就如，在第6行代码中a可以直接输出为2；而此时，在代码11行和代码23行，输出a的值就是ReferenceError。<br/><br/>就是说with内的赋值操作的规则是：赋值操作优先赋值到传入with内对象的对应属性，当没有对应的属性时，赋值操作会冒泡LHS查询对应的变量容器。<br/><br/>因此，当我们在with内书写c=2时，若传入的对象没有c属性，with会冒泡查询；若有c属性时，with会停止查找，赋值到此属性。<br/><br/>2.这段话：就是在代码3行，使用var声明变量b后，在with的作用域气泡外，即foo函数的气泡内可以访问变量b，即是此处var声明的变量属于with所在的作用域气泡。<br/><br/><br/><br/>当你理解到这里。with的欺骗词法在于，它会给传入对象创建一个作用域气泡，即词法作用域。<br/><br/>就是说，在这个气泡内a=2是不可以在外部访问的，而若此对象没有这个属性，a=2可以修改外部作用域气泡的变量。<br/><br/>说一下with的妙用，把eval嵌入到with内并给eval传入修改关联with对象属性的代码，就可以动态修改对象的数据了。但不要这样做，会导致性能极度下降。<br/><br/>希望读者自行将上述代码放行注释运行查看，有些细节，需要运行代码自我体会。<br/><br/>本章重要知识：<br/><br/>1.词法作用域就是定义在词法阶段的作用域，即作用域是由书写代码时函数声明的位置决定。<br/><br/>2.作用域会在找到第一个匹配的标识符时停止，因此会有“遮蔽效应。<br/><br/>3.欺骗词法：eval和with（会创建作用域气泡）<br/><br/>4.JavaScript引擎会在编译阶段进行数项的性能优化<br/><br/>5.欺骗词法会使得JavaScript引擎无法在编译时对作用域查找进行优化。<br/><br/>6.作用域查找始终从运行时所处的最内部作用域开始。<br/><br/>第3章 函数作用域和块作用域<br/>我认为本章的难点：<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.立执行函数的小例子<br/><br/>        undefined = true; //企图覆盖undeined<br/>        console.log(undefined); //undefined,可见修改不成功<br/>        (function IIFE(undefined) {<br/>            console.log(undefined) //undefined,<br/>            var a;<br/>            if (a === undefined) {<br/>                console.log(\'Undefined  is  safe  here!\')<br/>            }<br/>        })(); //没有传入参数<br/>这个例子，即是想覆盖默认值，但是实际发现，undefined并不会被覆盖<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.IIFE函数可以倒置代码的执行顺序<br/><br/>        var a = 2;<br/>        (function IIFE(def) {<br/>            def(window);<br/>        })(function def(global) {<br/>            var a = 3; //会有遮蔽效应<br/>            console.log(a); //3<br/>            console.log(global.a); //2<br/>        });<br/>这段代码其实很好理解，即def被当作参数传递给了IIFE，并在IIFE内部执行，两次输出的不同实质是遮蔽效应导致<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/><br/>本章重要知识：<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 1.无论标识符声明出现在作用域的何处买这个标识符所代表的标量或函数都将依附于所处作用域的气泡。（这里说的原理，应该就是变量提升和函数优先）<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 2.每一个函数内部都是一个作用域气泡，基于此，我们可以将代码包裹在函数作用域气泡内，这种基于作用域的隐藏方法即为最小特权原则。<br/><br/>        function foo() {<br/>            function bar(a) {<br/>                i = 3; //修改for循环中所属作用域中的i<br/>                for (var i = 0; i &lt; 10; i++) {<br/>                    bar(i * 2); //此时造成无限循环了<br/>                }<br/>            }<br/>        }<br/>&nbsp;这里就是出现了变量冲突，我们应该让bar函数内部的i成为本地变量。<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.很多库为了避免变量冲突，大都是定义一个独特的对象，让每个变量、方法成为变量的属性。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 4.具名函数和匿名函数表达式<br/><br/>        //注意，因为是表达式，所以结尾需要使用分号<br/>        //匿名函数表达式<br/>        (function() {<br/>            var a = 3;<br/>            console.log(a);<br/>        });<br/>        //具名函数表达式<br/>        (function foo() {<br/>            var a = 3;<br/>            console.log(a);<br/>        });<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.立执行函数表达式&nbsp;<br/><br/>        //形式一<br/>        (function foo(a) {<br/>            console.log(a);<br/>        }(3));<br/>        //形式二<br/>        (function foo(a) {<br/>            console.log(a);<br/>        })(3);<br/>&nbsp; &nbsp; &nbsp; &nbsp; 6.JavaScript语言表面上没有块级作用域的相关功能，实际上with（仅关联对象的属性同名标识符具有块级，语言表述能力有限，请自行到上述with解释查看。书中把这种表现形式称为块级，我觉得不够严谨，因为在with内声明的非同名属性标识符实际上是定义在with所在作用域气泡内的）、try/catch的catch均会创建一个块级作用域。try/catch的性能不佳<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 7.let关键字可以将变量绑定到所在的任意作用域中，即let可以为其声明的变量隐式地劫持了所在的块作用域。<br/><br/>第4章&nbsp; 提升<br/>我认为本章的难点：<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.块内作用域的函数提升机制。JavaScript未来可能会改变这种机制，因此尽量不要在块内声明函数。<br/><br/>        // foo(); //TypeError: foo is not a function<br/>        var a = true;<br/>        console.log(foo); //undefined<br/>        if (a) { //实际上被提升到if块内了<br/>            function foo() {<br/>                console.log(\'a\');<br/>            }<br/>        } else {<br/>            function foo() {<br/>                console.log(\'b\');<br/>            }<br/>        }<br/>        console.log(foo);<br/>本章重要知识点：<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.JavaScript编译器编译前会优先找到所有声明，并用合适的作用域将其关联起来。因此，包括变量和函数在内的所有声明都会在任何代码被执行前优先被处理。<br/><br/>        //写的是这<br/>        foo();<br/><br/>        function foo() {<br/>            console.log(a); //undefined<br/>            var a = 2;<br/>        }<br/>        //实际运行的是这<br/>        function foo() {<br/>            var a;<br/>            console.log(a);<br/>            a = 2;<br/>        }<br/>        foo();<br/>&nbsp; &nbsp; &nbsp; &nbsp; 2.函数声明和变量声明均会被提升，即函数名和变量名同名时，函数提升会导致忽略同名的变量。就是函数提升的优先级较高。<br/><br/>第5章&nbsp; 作用域闭包<br/>&nbsp; &nbsp; &nbsp; &nbsp; 此时我真正理解了什么是闭包，才体会到了 启示 ——&nbsp;JavaScript中的闭包无处不在！！！ 这句话的含义。<br/><br/>我认为本章的难点：<br/><br/>        function foo() {<br/>            var a = 2;<br/><br/>            function bar() {<br/>                console.log(a)<br/>            }<br/>            return bar;<br/>        }<br/>        foo()(); //2<br/>        var baz = foo(); //2<br/>        baz();<br/>闭包就是JavaScript引擎阻止了正在被引用函数的垃圾回收，即代码中bar持续被引用，也即是foo的作用域气泡持续被引用。<br/><br/>就行例子中，foo函数已经被执行了，foo函数理应会被回收，但是JavaScript引擎阻止了回收。<br/><br/>我们通俗的理解闭包，即为函数被封闭在作用域气泡内，函数的调用却在作用域气泡之外。<br/><br/>上述，是我试图用书中解释理解闭包，但总觉得过于学术，因此，我的理解：<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 0.我把函数的执行，理解为函数名是函数执行的开关，函数名()就会打开这个开关，“触发”函数。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 1.函数的执行、变量的取值均是一种“触发”；即函数名(),直接引用变量名，这些均是对函数及变量的“触发”。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 2.但是函数和变量不同，函数的执行是函数名()，函数名即为变量(我称变量为容器)，仅是存储函数的容器（实际上存放的是函数的指针，即函数的快捷方式），请看下述代码<br/><br/>        (function() {<br/>            function foo() {<br/>                var a = 2;<br/><br/>                function bar() {<br/>                    console.log(a)<br/>                }<br/>                return bar;<br/>            }<br/>            console.log(foo); //函数foo<br/>            console.log(window.foo); //undefined<br/><br/>            foo = 12;<br/>            console.log(foo) //12<br/>            console.log(window.foo); //undefined<br/>        })();<br/>&nbsp;说明foo可以被赋值，且不是window对象的属性，故可以断定foo就是一个变量(容器)，当然，其实学过C语言或者其他语言的都是知道这一点的，我仅是为了更加确定而已。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 3.因此，我说函数的“触发“需要两个条件：函数名和()。()会自动找到变量内的函数并执行<br/><br/>        //闭包的深度解析<br/>        function foo() {<br/>            var a = 2;<br/><br/>            function bar() {<br/>                console.log(a)<br/>            }<br/>            return bar;<br/>        }<br/>        foo()(); //2<br/>        var baz = foo(); //2<br/>        baz();<br/>&nbsp;在这段代码中，bar仅仅是一个存放函数的变量，执行函数foo后会返回bar变量。<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.现在拉回来，由于JavaScript是词法作用域，函数的执行，其执行的作用域是在函数定义的作用域气泡内。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 5.即函数foo是把bar函数的“触发”开关返回到了外面。外面使用()执行了foo内函数bar，接着就是正常词法作用域的操作了。<br/><br/>        function setupBot(name, selector) {<br/>            $(selector).click(function activator() {<br/>                console.log(\'Activating\' + name);<br/>            })<br/>        }<br/>        setupBot(\'Closure Bot 1\', \'#bot_1\')<br/>理解到这里，上面这段代码之所以是闭包，原因即是，内部回调函数的执行是由外部的setupBot控制的。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 6.解释下循环和闭包<br/><br/>        for (var i = 1; i &lt;= 5; i++) {<br/>            // var j = i;<br/>            setTimeout(function timer() {<br/>                console.log(j)<br/>            }, i * 1000);<br/>        }<br/>这里仅有两级作用域，全局作用域(for循环内)和回调函数内的作用作用域，根据词法作用域规则，回调函数作用域会共享全局作用域，故最终都会输出6<br/><br/>        for (var i = 1; i &lt;= 5; i++) {<br/>            (() =&gt; {<br/>                var j = i;<br/>                setTimeout(function timer() {<br/>                    console.log(j)<br/>                }, i * 1000);<br/>            })();<br/><br/>        }<br/>这里使用了立执行函数(ES6语法)，因此，此时有三级作用域，即全局作用域(for内)、立执行函数的作用域、回调函数的作用域。详细解释下：每次迭代会有5个立执行函数作用域同级和5个回调函数作用域同级，且分别是包含关系<br/><br/>故每次迭代时定义的 j 变量分别属于5个立执行函数的作用域，就是说没有 j 的进行数据存储的话，回调函数会由词法作用域规则向上冒泡查找i，这样还是输出5个6<br/><br/>        for (var i = 1; i &lt;= 5; i++) {<br/>            ((j) =&gt; {<br/>                setTimeout(function timer() {<br/>                    console.log(j)<br/>                }, j * 1000);<br/>            })(i);<br/><br/>        }<br/>这个改进之后的代码，事实上说明了，函数的每次执行，参数都会进行一次绑定。和使用let很像<br/><br/>        for (let i = 1; i &lt;= 5; i++) {<br/>            setTimeout(function timer() {<br/>                console.log(i)<br/>            }, i * 1000);<br/>        }<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.模块和闭包连用。模块就是一个封闭函数返回了一个对象(函数本质也是对象)，因此模块内部形成闭包，故可以通过返回的对象对模块内部持续引用，进行操作。<br/><br/>        var foo = (function CoolModule(id) {<br/>            function change() {<br/>                //修改公共API<br/>                publicAPI.identify = identify2;<br/>            };<br/>            function identify1() {<br/>                console.log(id);<br/>            };<br/><br/>            function identify2() {<br/>                console.log(id.toUpperCase());<br/>            };<br/>            var publicAPI = {<br/>                change: change,<br/>                identify: identify1<br/>            };<br/>            return publicAPI; //返回模块<br/>        })(\'foo module\');<br/>        //此时foo对其模块内部持续引用<br/>        //故下述方法执行了模块内部的函数<br/>        foo.identify();<br/>        foo.change();<br/>        foo.identify();<br/>&nbsp; 理解了闭包之后，理解模块变得轻而易举。上述代码没啥说的，就是模块产生了闭包，然后对模块内部的持续引用，进行的一些操作。<br/><br/>8.书中 现代模块机制 的一个代码案例<br/><br/>        //现代的模块机制<br/>        var MyModules = (function Manager() {<br/>            var modules = {};<br/><br/>            function define(name, deps, impl) {<br/>                for (var i = 0; i &lt; deps.length; i++) {<br/>                    deps[i] = modules[deps[i]];<br/>                };<br/>                modules[name] = impl.apply(impl, deps);<br/>            };<br/><br/>            function get(name) {<br/>                return modules[name];<br/>            };<br/>            return {<br/>                define: define,<br/>                get: get,<br/>            }<br/>        })();<br/>        MyModules.define(\'bar\', [], function() {<br/>            function heool(who) {<br/>                return \'Let me introduce: \' + who;<br/>            };<br/>            return { //返回的是对象<br/>                heool: heool<br/>            };<br/>        });<br/>        MyModules.define(\'foo\', [\'bar\'], function() {<br/>            var hungry = \'hippo\';<br/><br/>            function awesome() {<br/>                console.log(bar.hello(hungry).toUpperCase());<br/>            };<br/>            return { //返回的是对象<br/>                awesome: awesome<br/>            };<br/>        });<br/>        var bar = MyModules.get(\'bar\');<br/>        var foo = MyModules.get(\'foo\');<br/>        console.log(bar.hello(\'hippo\')); //Let me introduce:hippo<br/>        foo.awesome();<br/>&nbsp;其实挺好理解的，就是有点绕：<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 先说defined函数:一个参数name是会给modules添加一个属性，第二个参数deps就是对modules的属性遍历，并且将遍历的东西传入到第三个参数impl(回调函数)，第三个参数也会变成modules的属性。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 再说get函数：就是简单的获取moduls的属性<br/><br/>这里说一下代码中第一次执行MoModules.define()时传入了一个空数组，显然modules获取不到属性，则下面的impl.apply()传入的deps就是空了；也就是说apply的第二个参数是一个空，apply的第二个参数是传递给原函数的，即是第一次执行的时候，回调函数内没有传值。第二次同理。<br/><br/>当然，还是需要自己认真体会代码的。<br/><br/>9.关于附录C&nbsp; this词法的一些理解<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 在setTimeout中this指向了window，官网给出的答案是：由setTimeout()调用的代码运行在与所在函数完全分离的执行环境上<br/><br/>在我看来，obj.cool是指向了cool函数，js引擎在执行obj.cool()时，是一种obj修饰的调用；由此foo也指向了cool函数，故此时foo是对cool函数的直接引用，foo()执行时是不加修饰的调用；<br/><br/>因此，我认为setTimeout的参数就是相当于foo一样，是对cool函数的不加修饰的调用。<br/><br/>        //附录C  this词法<br/>        var obj = {<br/>            id: \'awesome\',<br/>            cool: function coolFn() {<br/>                console.log(this.id);<br/>                // console.log(this);<br/>            }<br/>        };<br/>        var id = \'not awesome\';<br/>        obj.cool(); //awesome<br/>        //this的绑定取决于调用位置，故这里是对coolFn函数的直接引用，即直接调用<br/>        var foo = obj.cool;<br/>        foo(); //not awesome<br/><br/>        // 可见这里也是直接引用<br/>        setTimeout(obj.cool, 100); //not awesome<br/>        // console.log(window.id)<br/>本章知识点：<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 1.基本都是难点，要记得不多，但均需要理解。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 2.模块模式的必要条件：<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ①必须由外部的粉笔函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ②封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 3.模块文件中的内容会被当做包含在作用域闭包中一样处理。类似于函数闭包模块.<br/><br/>第二部分&nbsp; this和对象模型<br/>第1章&nbsp; 关于this<br/>本章就是讲了一些对this的误区<br/><br/>我认为的本章难点：<br/><br/>无<br/><br/>书中本章知识点：<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 1.为什么要使用this？this提供了一种更简洁且易于复用的API设计，我们可以通过更改this指向，隐式的“传递”一个对象的引用。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 2.this不指向自身。<br/><br/>        // 关于this<br/>        function foo(num) {<br/>            console.log(\'foo: \' + num);<br/>            //记录foo被调用的次数<br/>            this.count++;<br/>        };<br/>        foo.count = 0;<br/>        var i = null;<br/>        for (i = 0; i &lt; 10; i++) {<br/>            if (i &gt; 5) {<br/>                foo(i);<br/>            }<br/>        }<br/>        console.log(foo.count); //0<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.this在任何情况下都不指向函数的词法作用域，作用域存在于JavaScript引擎内部。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 4.经典的this错误，它试图跨越边界<br/><br/>        var obj = {}<br/><br/>        function foo() {<br/>            var a = 2;<br/>            this.bar();<br/>        }<br/><br/>        function bar() {<br/>            // LHS查询对象的时候貌似会自动创建属性，应该时新改的。<br/>            console.log(this.a); //undefined<br/>            console.log(obj.a); //undefined<br/>        }<br/>        // this.foo(); //undefined<br/>        //我觉得定义在全局作用域的函数也会成为全局对象的属性<br/><br/>        foo();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.this的绑定和函数的声明位置没有任何关系，只取决于函数的调用方式&nbsp;.即this实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。<br/><br/>第2章&nbsp; this全面解析<br/>本章就是说了this的指向的规则，及怎么修改this指向，<br/><br/>我认为的本章难点：<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 1.书中的MDN的bind实现，最后的部分没看懂<br/><br/>      if (!Function.prototype.bind) { //检擦Function的原型是否有bind方法<br/>            Function.prototype.bind = function(OThis) { //定义bind方法<br/>                if (typeof this !== \'function\') { //检查调用者是否是函数<br/>                    //与 ECMAScript 5最接近的<br/>                    //内部 IsCallacle 函数<br/>                    throw new TypeError( //如果不是函数，则抛出一个错误，这个函数会停止后续代码的执行<br/>                        \'Function.prototype.bind - what is trying\' +<br/>                        \'to be bound is not callable\'<br/>                    );<br/>                };<br/>                //分割bind函数的参数，slice可以分割arguments这个伪数组，1代表从第2个索引开始分割arguments<br/>                var aArgs = Array.prototype.slice.call(arguments, 1),<br/>                    fToBind = this, //bind调用者<br/>                    fNOP = function() {}, //<br/>                    fBound = function() {<br/>                        return fTobind.apply(<br/>                            (<br/>                                this instanceof fNOP //fNOP的原型链是否在this原型链上<br/>                                &amp;&amp;<br/>                                OThis ? this : OThis //oThis是否存在<br/>                            ),<br/>                            aArgs.concat(<br/>                                Array.prototype.slice.call(arguments)<br/>                            )<br/>                        );<br/>                    };<br/>                fNOP.prototype = this.prototype;<br/>                fBound.prototype = new fNOP();<br/>                return fBound;<br/>            }<br/>        }<br/>&nbsp; &nbsp; &nbsp; &nbsp; 2.书中软绑定源码，我现在还没能完全理解<br/><br/>        //软绑定<br/>        if (!Function.prototype.softBind) {<br/>            Function.prototype.softBind = function(obj) {<br/>                var fn = this;<br/>                //捕获所欲curried参数<br/>                var curried = [].slice.call(arguments, 1);<br/>                var bound = function() {<br/>                    return fn.apply(<br/>                        (!this || this === (window || global)) ?<br/>                        obj : this,<br/>                        curried.concat.apply(curried, arguments)<br/>                    );<br/>                };<br/>                bound.prototype = Object.create(fn.prototype);<br/>                return bound;<br/>            }<br/>        }<br/><br/>        function foo() {<br/>            console.log(\'name: \' + this.name);<br/>        }<br/>        var obj = {<br/>                name: \'obj\'<br/>            },<br/>            obj2 = {<br/>                name: \'obj2\'<br/>            },<br/>            obj3 = {<br/>                name: \'obj3\'<br/>            };<br/>        var fooOBJ = foo.softBind(obj); //绑定到了obj上<br/>        fooOBJ(); //name:obj<br/>        obj2.foo = foo.softBind(obj);//绑定到obj上<br/>        obj2.foo(); //name:obj2，貌似和隐式绑定差不多<br/>        fooOBJ.call(obj3); //name:obj3<br/>        setTimeout(obj2.foo, 100); //name:obj<br/>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3.箭头函数会捕获调用上级函数的this，且无法修改。箭头函数可以像bind一样确保函数的this被绑定到指定对象，实质是使用词法作用域取代了this机制，内部有类似于var self = this;这句代码&nbsp; &nbsp;<br/><br/>        //箭头函数<br/>        function foo() {<br/>            //返回一个箭头函数<br/>            return (a) =&gt; {<br/>                //this继承自foo()<br/>                console.log(this.a)<br/>            }<br/>        }<br/>        var obj1 = {<br/>            a: 2<br/>        };<br/>        var obj2 = {<br/>            a: 3<br/>        };<br/>        var bar = foo.call(obj1);<br/>        bar.call(obj2); //2<br/>本章重要知识点：<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 1.调用位置就是函数在代码中被调用的位置（而不是声明位置）。需要分析调用栈。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 2.函数运行在“非严格模式”下，函数会执行默认绑定；但在严格模式下调用函数，则不影响函数的默认绑定 。区分一下运行和调用。默认绑定就是全局函数默认绑定到全局对象上。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 3.当函数引用有上下文对象时，隐式绑定规则会把函数调用中的this绑定到这个上下文对象。对象的属性引用链中只有上一层或者说最后一层在调用位置中起作用<br/><br/>        function foo() {<br/>            console.log(this.a)<br/>        }<br/>        var obj2 = {<br/>            a: 42,<br/>            foo: foo<br/>        }<br/>        var obj1 = {<br/>            a: 2,<br/>            obj2: obj2<br/>        }<br/>        obj1.obj2.foo(); //42<br/>&nbsp; &nbsp; &nbsp; &nbsp; 3.&nbsp;隐式绑定造成this丢失的实质是对一个函数的直接引用（不带任何修饰的函数调用）<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 4.回调函数的函数可能会修改this，流行的JavaScript库中事件处理器常会把回调函数的this强制绑定到触发事件的DOM元素上。我是用jQuery发现并没有像后半句所说的那样<br/><br/>        window.addEventListener(\'load\', function() {<br/>            console.log(this); //window<br/>            document.querySelector(\'p\').addEventListener(\'click\', function(e) {<br/>                function foo() {<br/>                    console.log(this); //window<br/><br/>                }<br/>                foo();<br/>                //这里就是绑定到触发的DOM元素上<br/>                console.log(this); //p<br/>                console.log(e.target); //p<br/>            })<br/>        })<br/>        $(function() {<br/>            console.log(this); //#document,貌似是jQuery的文档对象<br/>            $(\'p\').on(\'click\', function(e) {<br/>                function foo() {<br/>                    console.log(this); //window<br/>                }<br/>                foo();<br/>                console.log(this); //p<br/>                console.log(e.target); //p<br/>            })<br/>        })<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.硬绑定call和apply2。硬绑定就是使用新函数对call和apply语句进行了隔离。<br/><br/>        //硬绑定，<br/>        function foo() {<br/>            console.log(this.a)<br/>        }<br/>        var obj = {<br/>            a: 2,<br/>            foo: foo<br/>        };<br/>        var a = 3;<br/>        var bar = function() {<br/>            // foo();<br/>            return foo.call(obj); //2<br/>        };<br/>        bar();<br/>        setTimeout(bar, 100); //2<br/>        //硬绑定的bar不可能再修改它的this。<br/>        //上面这句和废话一样，bar现在是一个新函数，这些操作均是对新函数的操作，怎么会修改foo的this<br/>        bar.call(window); //2<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.new操作符调用的是普通函数，即所有函数均可使用new调用。不存在所谓的”构造函数“，只有对于函数的”构造调用“，new的操作：<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.创建（或者说构造）一个全新的对象<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.这个新对象会被执行[[Prototype]]连接<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3.这个新对象会被绑定到函数调用的this<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4.如果函数没有返回其他对象，那么new表达式的函数调用会自动返回这个新对象&nbsp;<br/><br/>        function foo(a) {<br/>            this.a = a;<br/>        }<br/>        var bar = new foo(2);<br/>        //返回了一个新对象，因此可以bar.a访问新对象的属性<br/>        console.log(bar.a); //2<br/>&nbsp; &nbsp; &nbsp; 7.判断this：<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ①函数是否在new中调用(new 绑定)？如果是的话this绑定的是新创建的对象。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var&nbsp; bar = new foo();<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ②函数是否通过call、apply（显示绑定）或着硬绑定调用?如果是的话，this绑定的是指定的对象。<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp; bar&nbsp;= foo.call(obj2)<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ③函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this绑定的是那个上下文对象。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var bar =obj1.foo();<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ④如果均不是的话，使用默认绑定。如果严格模式下，就绑定到undefined，否则绑定到全局对象。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var&nbsp; bar&nbsp; =&nbsp; foo();<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 8.柯里化：把除了第一个参数（第一个参数用于绑定this）之外的其他参数都传给下层的函数（这种技术称为”部分应用“，是“柯里化”的一种）<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 9.JavaScript中创建一个空对象最简单的方法都是object.create(null)。这么做不会创建object.prototype这个委托，比{}“更空”。<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.对于默认绑定来说，决定this绑定对象的并不是调用位置是否处于严格模式，而是函数体是否处于严格模式。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 11.硬绑定会大大降低函数的灵活性，使用硬绑定之后就无法使用隐式绑定或者显示绑定来修改this。<br/><br/>第3章&nbsp; 对象<br/>有一种常见的说法“JavaScript中万物皆是对象”，这显然是错误的。<br/><br/>本章就是讲了对象的一些操作：创建、配置、封印<br/><br/>本章难点：<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.Symbol.iterator：为每一个对象定义了默认的迭代器。该迭代器可以被 for-of&nbsp;循环使用。for-of会找内置的@@iterator对象并调用next()方法来遍历数据<br/><br/>        //自定义对象迭代器<br/>        var myObject = {<br/>            a: 2,<br/>            b: 3<br/>        };<br/>        Object.defineProperty(myObject, Symbol.iterator, {<br/>                enumerable: false,<br/>                writable: false,<br/>                configurable: true,<br/>                value: function() {<br/>                    var o = this;<br/>                    var idx = 0;<br/>                    var ks = Object.keys(o);<br/>                    return {<br/>                        next: function() {<br/>                            return {<br/>                                value: o[ks[idx++]],<br/>                                done: (idx &gt; ks.length)<br/>                            };<br/>                        }<br/>                    };<br/>                }<br/>            })<br/>            //手动遍历myObject<br/>        var it = myObject[Symbol.iterator]();<br/>        console.log(it.next()); //{value:2,done:false}<br/>        console.log(it.next()); //{value:3,done:false}<br/>        console.log(it.next()); //{value:undefined,done:true}<br/>        //for-of遍历<br/>        for (var v of myObject) {<br/>            console.log(v)<br/>        }; //2,3<br/>&nbsp;代码的意思就是定义了一个Symbol.iterator属性，这个属性的value是个函数，函数内部有各种操作。文字表达起来有点费劲，可以尝试运行代码自行体会<br/><br/>本章知识点：<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.JavaScript的六种主要类型：string，number，boolean，null，undefined，object。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typeof&nbsp; null;之所以返回Object，是因为JavaScript中二进制前三位均为0，就会被判定为object类型，而null的二进制表示全为0，自然被判定为object了<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 2.内置对象：String，Number，Boolean，Object，Function，Array，Date，RegExp，Error。<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.JavaScript会自动将字符串，数字等使用方法时，会转换为内置对象，如‘I am string’，实际上会进行new String(‘I am string’)<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 4.在对象中，属性名永远是字符串，如果你使用string（字面量，字符串的存储是固定的）以外的其他值作为属性名，那它首先会被转换为一个字符串；<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 5.数组也是对象，因此可以给数组添加属性，但是如果试图给数组添加一个类数字属性，进行键访问的时候，此属性会变成一个数值下标<br/><br/>        var myArray = [\'foo\', \'turnip\', 43];<br/>        myArray[\'3\'] = \'kkk\';<br/>        myArray.length; //4<br/>        myArray[3]; //43<br/>&nbsp; &nbsp; &nbsp; &nbsp; 6.Object.defineProperty官方描述：Object.defineProperty。该方法可以配置对象<br/><br/>        \'use strict\' //修改只读属性，会报错<br/>        var myObject = {};<br/>        Object.defineProperty(myObject, \'a\', {<br/>            value: 2,<br/>            writeable: false, //不可写,只读<br/>            configurable: true, //可配置的<br/>            enumerable: true //可枚举<br/>        });<br/>        myObject.a = 3;<br/>        console.log(myObject.a); //2<br/>&nbsp; &nbsp; &nbsp; &nbsp; 7.结合 writeable:false和configurable:false 就可以创建一个真正的常量属性(不可修改、重定义或删除)<br/><br/>        var myObject = {};<br/>        Object.defineProperty(myObject, \'FAVORITE_NUMBER\', {<br/>            value: 42,<br/>            writable: false,<br/>            configurable: false<br/>        })<br/>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;8.Object.preventExtensions官方解释：Object.preventExtensions。该方法可以让一个对象变的不可扩展，也就是永远不能再添加新的属性。<br/><br/>        var myObject = {<br/>            a: 2<br/>        };<br/>        Object.preventExtensions(myObject);<br/>        myObject.b = 3;<br/>        console.log(myObject.b); //undefined<br/>&nbsp; &nbsp; &nbsp; &nbsp; 9.Object.seal()官方解释：Object.seal。该方法封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置、不可删除。当前属性的值只要原来是可写的就可以改变。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 10.Object.freeze()官方解释：Object.freeze()。这个方法是可以应用在对象上的级别对高的不可变性。<br/><br/>&nbsp; &nbsp;11.getter和setter均是一个隐藏函数，前者获取属性时调用，后者设置属性时调用。<br/><br/>        var myObject = {<br/>            //给a定义一个getter<br/>            get a() {<br/>                return this._a_;<br/>            },<br/>            set a(val) {<br/>                this._a_ = val * 2;<br/>            }<br/>        }<br/>        myObject.a = 2;<br/>        console.log(myObject.a);//4<br/>        console.log(myObject._a_); //4，创建了一个属性<br/>&nbsp; &nbsp; &nbsp; &nbsp; 11可枚举 就相当于 可以出现在对象属性的遍历中。for-in会静默，但是for循环可以。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; propertyIsEnumerable()会检查给定的属性名是否直接存在于对象中（而不是原型链上）并且满足enumerable：true<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; Object.keys()会返回一个数组，包含所有可枚举的属性，Object,getOwnpropertyNames()会返回一个数组，包含所有属性，无论他们是否可枚举；<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object.prototype.hasOwnProperty和in的区别在于是否查找[[Prototype]]链<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; object.keys()和Object.getOwnPropertyNames()都只会查找对象直接包含的属性<br/><br/>        var myObject = {};<br/>        Object.defineProperty(myObject, \'a\',<br/>            //让a像普通属性一样可以枚举<br/>            {<br/>                enumerable: true,<br/>                value: 2<br/>            });<br/>        Object.defineProperty(myObject, \'b\',<br/>            //让a像普通属性一样可以枚举<br/>            {<br/>                enumerable: false,<br/>                value: 2<br/>            });<br/>        console.log(myObject.b); //3<br/>        console.log((\'b\' in myObject)); //true<br/>        console.log(myObject.hasOwnProperty(\'b\')); //true<br/>        for (var key in myObject) {<br/>            console.log(key, myObject[key]);<br/>        }; //\'a\' 2<br/>        console.log(myObject.propertyIsEnumerable(\'a\')); //true<br/>        console.log(myObject.propertyIsEnumerable(\'b\')); //false<br/>        console.log(Object.keys(myObject)); //[\'a\']<br/>        console.log(Object.getOwnPropertyNames(myObject)); //[\'a\',\'b\']<br/>第4章&nbsp; 混合对象 “类”<br/>只要理解了this指向和对象，这一章的内容理解起来很容易，都是一些概念而已。<br/><br/>本章难点：<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 1.多态就是任何方法均可以引用继承层次中高层的方法，及继承使得方法可以在多类中映射。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 2.显示多态就是把显示的将父类的方法引入子类，但此时方法显示绑定的对象是子类<br/><br/>本章知识点：<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 1.类/继承描述了一种代码的住址结构——一种在软件中对真实世界中问题领域的建模方法，面向对象编程强调的是数据和操作数据的行为本质上是互相关联的。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 2.JavaScript中并没有类，JavaScript只是提供了一些近似类的语法，因此JavaScript的类是一种设计模式(类本身就是一种设计模式)。如ES6的class<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 3.类实例是由一个特殊的类方法构造的，这个方法名通常和类同名，被称为构造函数。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 4.类的继承其实就是复制<br/><br/><br/>第5章&nbsp; 原型<br/>原型的实质就是对象之间的关联关系。<br/><br/>本章难点：<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 1.原型的本质就是一种关联关系，原型链就是关联树，即JavaScript引擎会查找原型链<br/><br/>        var anotherObject = {<br/>            a: 2<br/>        };<br/>        //创建一个关联到anotherObject的对象<br/>        var myObject = Object.create(anotherObject);<br/>        //注意此时myObject.a并不存在，但是JavaScript引擎会在原型链上查找该属性<br/>        console.log(myObject.a); //2<br/>&nbsp; &nbsp; &nbsp; &nbsp; 2.隐式屏蔽<br/><br/>        var anotherObject = {<br/>            a: 2<br/>        };<br/>        var myObject = Object.create(anotherObject);<br/>        console.log(anotherObject.a); //2<br/>        console.log(myObject.a); //2<br/>        console.log(anotherObject.hasOwnProperty(\'a\')); //true<br/>        console.log(myObject.hasOwnProperty(\'a\')); //false<br/>        console.log(anotherObject);<br/>        console.log(myObject); //属于anotherObject下一级<br/>        myObject.a++; //myObject.a= myObject.a + 1<br/>        console.log(anotherObject.a); //2<br/>        console.log(myObject.a); //3<br/>        console.log(myObject.hasOwnProperty(\'a\')); //true<br/>&nbsp; &nbsp; &nbsp; &nbsp; 3.new的关联，new的操作，就是创建了一个关联到其他对象的新对象。实际上我们并没有复制“类“，只是让他们关联而已<br/><br/>        function Foo() {}<br/>        var a = new Foo();<br/>        //new操作后，都会被关联到Foo.prototype对象上<br/>        console.log(Object.getPrototypeOf(a) === Foo.prototype); //true<br/>本章知识点：<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.使用for-in&nbsp;遍历对象时原理和查找[[Prototype]]链类似，任何可以通过原型链访问到的属性都会被枚举。使用in操作符来检查属性在对象中是否存在时，同样会查找对象的整条原型链。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 2.所有普通的[[Prototype]]链最终都会指向内置的Object.prototype。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 3.函数不是构造函数，但当且仅当使用new时，函数调用会变成”构造函数调用“。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 4.Object.create()会创建一个新对象，并把它关联到我们指定的对象上<br/><br/>        //兼容的Object.create<br/>        if (!Object.create) {<br/>            Object.create = function(o) {<br/>                function F() {}; //声明空函数<br/>                F.prototype = o;<br/>                return new F();<br/>            }<br/>        }<br/>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5.内部委托。避免明明当前对象没有这个属性，但是却神奇的可以调用。也使得API设计更加清晰<br/><br/>        var anotherObject = {<br/>            cool: function() {<br/>                console.log(\'cool!\');<br/>            }<br/>        }<br/>        var myObject = Object.create(anotherObject);<br/>        myObject.doCool = function() {<br/>            this.cool(); //内部委托<br/>        }<br/>        myObject.doCool();<br/>第6章&nbsp; 行为委托<br/>这一章没什么可说的，就是对委托这种设计模式的讲解，理解了this机制、对象、原型之后，书中的代码也并没有什么难点。<br/><br/>知识回顾：<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 1.如果在第一个对象上没有找到需要的属性或者方法引用，JavaScript引擎会继续在[[Prototype]]关联的对象上进行查找。&nbsp;<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 2.JavaScript的原型链机制的本质就是对象与对象之间的关联关系。<br/><br/>本章难点：<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 1.类理论和委托理论的对比：<br/><br/>        //类理论(伪代码)<br/>        class Task {<br/>            id;<br/>            //函数Task()<br/>            Task(ID) {<br/>                id = ID;<br/>            }<br/>            outputTask() {<br/>                output(id);<br/>            }<br/>        };<br/>        class XYZ inherits Task {<br/>            label;<br/>            //构造函数XYZ<br/>            XYZ(ID, Label) {<br/>                super(ID);<br/>                label = Label;<br/>            }<br/>            outputTask() {<br/>                super();<br/>                output(label);<br/>            }<br/>        };<br/>        class ABC inherits Task {<br/>            //...<br/>        };<br/><br/>        //委托理论<br/>        Task = {<br/>            setID: function(ID) {<br/>                this.id = ID;<br/>            },<br/>            output: function() {<br/>                console.log(this.id)<br/>            }<br/>        };<br/>        // 让XYZ委托给Task<br/>        XYZ = Object.create(Task);<br/>        XYZ.prepareTask = function(ID,Label){<br/>            this.setID(ID);<br/>            this.label = Label;<br/>        }<br/>        XYZ.outputTaskDetails = function(){<br/>            this.outputID();<br/>            console.log(this.label);<br/>        };<br/>        //ABC = Object.create(Task);<br/>        //ABC ... = ...<br/>可以看出，类理论：当实例化子类时，子类的实例会复制父类和子类的行为&nbsp;。&nbsp;可参考java类原理<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 委托理论：”子类“(对象)通过[[Prototype]]委托给了”父类“，当调用子类中没有的方法时，会通过委托关系查找关联的对象，又由于调用位置触发this的隐式绑定规则，故this的绑定仍是”子类“，而这正是我们想要的结果。由此看来委托的设计模式更加简洁。&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br/><br/>本章知识点：<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 无<br/><br/><br/></p>','你不知道的JavaScript 上卷 知识梳完结语：2021年7月2日，终于写完了。我原本是想用一周的时间看完这本上卷的，也是没想到前前后后竟然花了十多天的时间。还好，收获还是挺多的，书中的内容的确让我对JavaScript这门语言有了更深的认识。这个知识梳理适合那些已经看完了《你不知道的JavaScript&nbsp;上卷》，但仍觉得一头雾水的人，我也看了很多博主写了这本书的知识梳理，大都是对书中内容的简单堆砌，及简单的加以说明，这让我这个JavaScript小白在理解书中的概念时总是一头雾水，可能是初学的原因，我看到书中很多概念的时候，就像学了一个数学定理，也知道这个定理的意思，但是却不知道这个数学定理怎么使用，也无从知道书中表达的意思，故在数学学习的过程中我经常渴望知道别人的理解。因此，我决定自己写一篇《你不知道的JavaScript》知识梳理，认真揣摩作者的意思，以便更通俗的理解书中概念，尽量领会书中的每一章要表达什么。这本书看的较为仓促。若有错误，望评论区指正，我会仔细查阅资料并给予修改。再过不久，我便会看剩下的两本书，我也会在博客里写出我的理解，希望看客们可以关注我，并可以给我一些指正。第一部分&nbsp; 作用域和闭包第1章&nbsp; 作用域是什么我觉得本章的难点：先来回答本章的标题：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作用域是什么？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作用域就是变量和函数的可访问范围，控制着变量和函数的可见性与生命周期。使用数学中的函数理解，说白了作用域就是取值范围。        function　 foo(a) {            console.log(a); //2        };        foo(2);上述代码是引擎和作用域的对话。这里注意，&nbsp;LHS和RHS是对于赋值操作( foo()函数的执行也可以理解为赋值操作，相当于是将一个函数赋值给foo，然后执行foo)，即赋值操作左边是否有我们要存放的容器，赋值操作右边是否有我们操作的值即LHS查询：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行foo()时，对foo的查询（是一个函数）&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;执行foo(2)时，对foo内的a进行查询（a是参数）RHS查询：&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 执行foo(2)时，对a的赋值操作&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 执行console.log()时，对log()方法的引用&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 执行console.log(a)时，对a赋值的操作由上述我们可以理解：为什么RHS查询会出现两种错误ReferenceError和TypeError了前者是因为找不到赋值操作，后者是因为找到了，但是进行了不合理的操作，例如这样   let foo = null;        foo(2);&nbsp;因此，我觉得TypeError错误可以理解为RHS查询成功了，但是进行了非法操作。当然这些书中提到了，我这里是梳理了一边逻辑。这是小测验的代码，看完书里的解释，又理解了上面的内容，这个小测验就是小菜一碟        function foo (a){            var b = a;            return a + b;        };        var c = foo( 2 );LHS查询：即赋值操作左边的容器。RHS查询：即赋值操作右边的值。LHS：c=，a=2（foo(2)的隐式操作，就是找有没有a这个参数，因为即便函数有形参也可以不写实参），b=其实我困惑在为什么a=2的赋值操作右边的=2不定义为RHS查询；我这里猜一下，是因为=2不用查，因为2本身就是值，查询的实质是找，变量是存储数据的容器，因此才需要找。RHS：foo这个函数，=a，return a+b的a和b(return相当于是一个赋值操作a+b是赋值操作的值)，本章重要知识：&nbsp; &nbsp; &nbsp; &nbsp; 1.JavaScript是编译语言，其编译发生在代码执行前的几微妙。即编译和执行几乎同步。因此JavaScript会用尽各种办法进行性能性能优化。&nbsp; &nbsp; &nbsp; &nbsp; 2.引擎、编译器、作用域。简单了解作用即可。&nbsp; &nbsp; &nbsp; &nbsp; 3.LHS和RHS查询&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 4.作用域嵌套：即在嵌套的作用域中，引擎的LHS查询会实行冒泡规则查找&nbsp; &nbsp; &nbsp; &nbsp; 5.不成功的LHS查找会自动创建一个全局变量（非严格模式），严格模式下会抛出ReferenceError异常，不成功的RHS查询会抛出ReferenceError异常第2章&nbsp;词法作用域我认为本章的难点：先通俗回答本章的标题：&nbsp; &nbsp; &nbsp; &nbsp; 词法作用域：即是语言给代码的书写提供了一套书写规则，按照这个规则而形成的作用域就是词法作用域，说白了就是代码块的作用范围。例如书写函数时，函数内部的数据，外部一般无法访问，这个函数作用范围就是词法作用域的一部分。&nbsp;在这张图中，这三个作用域气泡就是词法作用域，即是按照代码的书写规则来，形成的代码块的作用范围。作用域气泡严格包含，即只会出现气泡包含，不会出现气泡交叉解释一下书中附录A中提到的动态作用域&nbsp; &nbsp; &nbsp; &nbsp; 1.JavaScript只有词法作用域！（但this机制和动态作用域很像）        function foo() {            console.log(this.a); //2            console.log(a); //2        }        function bar() {            var a = 3;            foo();        }        var a = 2;        bar();&nbsp;这里如果JavaScript是动态作用域，那么输出的将会是3，因为动态作用域会查找调用栈。&nbsp; &nbsp; &nbsp; &nbsp; 2.词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定的。关于eval欺骗词法详解        //eval欺骗词法        function foo(str, a) {            eval(str); //欺骗            console.log(a, b);        }        var b = 2;        foo(\'var b = 3;\', 1)&nbsp;基本上没啥好说的，就是会直接把传入的字符串转换为js代码，即此时的eval(str)完全等价于var b = 3;说一下这个函数的妙用，eval会执行字符串，当我们的到的数据是可以执行的字符串时，那么使用eval还是挺炫的。关于with欺骗词法的详解先说理解，with会关联一个对象，并且with内的变量均会映射到关联对象的同名属性。with内的变量若没有映射到同名属性，则会LHS查询向上冒泡        function foo(obj) {            with(obj) { //会创建作用域气泡                var b = 3; //实际上会被定义在foo函数内                // let c = 6;//会被限制在with内                a = 2; //这个a会直接找obj的属性a                console.log(a); //2                console.log(obj.a); //undefined                console.log(b); //3                console.log(obj.b); //undefined            };            // console.log(a) //ReferenceError            console.log(b); //3            // console.log(c);        };        var o1 = {            a: 3        }        var o2 = {            b: 3        };        foo(o1);        console.log(o1.a); //2        // // console.log(a); //RHS查询，ReferenceError        // foo(o2);        // console.log(o2.a); //undefined        // console.log(o2.b); //undefined        // console.log(a); //2,window.a&nbsp;1.这句话的前半句就是说with会创建一个作用域气泡；后半句就是说传入对象的属性会关联到with作用域气泡内的同名标识符。就如，在第6行代码中a可以直接输出为2；而此时，在代码11行和代码23行，输出a的值就是ReferenceError。就是说with内的赋值操作的规则是：赋值操作优先赋值到传入with内对象的对应属性，当没有对应的属性时，赋值操作会冒泡LHS查询对应的变量容器。因此，当我们在with内书写c=2时，若传入的对象没有c属性，with会冒泡查询；若有c属性时，with会停止查找，赋值到此属性。2.这段话：就是在代码3行，使用var声明变量b后，在with的作用域气泡外，即foo函数的气泡内可以访问变量b，即是此处var声明的变量属于with所在的作用域气泡。当你理解到这里。with的欺骗词法在于，它会给传入对象创建一个作用域气泡，即词法作用域。就是说，在这个气泡内a=2是不可以在外部访问的，而若此对象没有这个属性，a=2可以修改外部作用域气泡的变量。说一下with的妙用，把eval嵌入到with内并给eval传入修改关联with对象属性的代码，就可以动态修改对象的数据了。但不要这样做，会导致性能极度下降。希望读者自行将上述代码放行注释运行查看，有些细节，需要运行代码自我体会。本章重要知识：1.词法作用域就是定义在词法阶段的作用域，即作用域是由书写代码时函数声明的位置决定。2.作用域会在找到第一个匹配的标识符时停止，因此会有“遮蔽效应。3.欺骗词法：eval和with（会创建作用域气泡）4.JavaScript引擎会在编译阶段进行数项的性能优化5.欺骗词法会使得JavaScript引擎无法在编译时对作用域查找进行优化。6.作用域查找始终从运行时所处的最内部作用域开始。第3章 函数作用域和块作用域我认为本章的难点：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.立执行函数的小例子        undefined = true; //企图覆盖undeined        console.log(undefined); //undefined,可见修改不成功        (function IIFE(undefined) {            console.log(undefined) //undefined,            var a;            if (a === undefined) {                console.log(\'Undefined  is  safe  here!\')            }        })(); //没有传入参数这个例子，即是想覆盖默认值，但是实际发现，undefined并不会被覆盖&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.IIFE函数可以倒置代码的执行顺序        var a = 2;        (function IIFE(def) {            def(window);        })(function def(global) {            var a = 3; //会有遮蔽效应            console.log(a); //3            console.log(global.a); //2        });这段代码其实很好理解，即def被当作参数传递给了IIFE，并在IIFE内部执行，两次输出的不同实质是遮蔽效应导致&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本章重要知识：&nbsp; &nbsp; &nbsp; &nbsp; 1.无论标识符声明出现在作用域的何处买这个标识符所代表的标量或函数都将依附于所处作用域的气泡。（这里说的原理，应该就是变量提升和函数优先）&nbsp; &nbsp; &nbsp; &nbsp; 2.每一个函数内部都是一个作用域气泡，基于此，我们可以将代码包裹在函数作用域气泡内，这种基于作用域的隐藏方法即为最小特权原则。        function foo() {            function bar(a) {                i = 3; //修改for循环中所属作用域中的i                for (var i = 0; i &lt; 10; i++) {                    bar(i * 2); //此时造成无限循环了                }            }        }&nbsp;这里就是出现了变量冲突，我们应该让bar函数内部的i成为本地变量。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.很多库为了避免变量冲突，大都是定义一个独特的对象，让每个变量、方法成为变量的属性。&nbsp; &nbsp; &nbsp; &nbsp; 4.具名函数和匿名函数表达式        //注意，因为是表达式，所以结尾需要使用分号        //匿名函数表达式        (function() {            var a = 3;            console.log(a);        });        //具名函数表达式        (function foo() {            var a = 3;            console.log(a);        });&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.立执行函数表达式&nbsp;        //形式一        (function foo(a) {            console.log(a);        }(3));        //形式二        (function foo(a) {            console.log(a);        })(3);&nbsp; &nbsp; &nbsp; &nbsp; 6.JavaScript语言表面上没有块级作用域的相关功能，实际上with（仅关联对象的属性同名标识符具有块级，语言表述能力有限，请自行到上述with解释查看。书中把这种表现形式称为块级，我觉得不够严谨，因为在with内声明的非同名属性标识符实际上是定义在with所在作用域气泡内的）、try/catch的catch均会创建一个块级作用域。try/catch的性能不佳&nbsp; &nbsp; &nbsp; &nbsp; 7.let关键字可以将变量绑定到所在的任意作用域中，即let可以为其声明的变量隐式地劫持了所在的块作用域。第4章&nbsp; 提升我认为本章的难点：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.块内作用域的函数提升机制。JavaScript未来可能会改变这种机制，因此尽量不要在块内声明函数。        // foo(); //TypeError: foo is not a function        var a = true;        console.log(foo); //undefined        if (a) { //实际上被提升到if块内了            function foo() {                console.log(\'a\');            }        } else {            function foo() {                console.log(\'b\');            }        }        console.log(foo);本章重要知识点：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.JavaScript编译器编译前会优先找到所有声明，并用合适的作用域将其关联起来。因此，包括变量和函数在内的所有声明都会在任何代码被执行前优先被处理。        //写的是这        foo();        function foo() {            console.log(a); //undefined            var a = 2;        }        //实际运行的是这        function foo() {            var a;            console.log(a);            a = 2;        }        foo();&nbsp; &nbsp; &nbsp; &nbsp; 2.函数声明和变量声明均会被提升，即函数名和变量名同名时，函数提升会导致忽略同名的变量。就是函数提升的优先级较高。第5章&nbsp; 作用域闭包&nbsp; &nbsp; &nbsp; &nbsp; 此时我真正理解了什么是闭包，才体会到了 启示 ——&nbsp;JavaScript中的闭包无处不在！！！ 这句话的含义。我认为本章的难点：        function foo() {            var a = 2;            function bar() {                console.log(a)            }            return bar;        }        foo()(); //2        var baz = foo(); //2        baz();闭包就是JavaScript引擎阻止了正在被引用函数的垃圾回收，即代码中bar持续被引用，也即是foo的作用域气泡持续被引用。就行例子中，foo函数已经被执行了，foo函数理应会被回收，但是JavaScript引擎阻止了回收。我们通俗的理解闭包，即为函数被封闭在作用域气泡内，函数的调用却在作用域气泡之外。上述，是我试图用书中解释理解闭包，但总觉得过于学术，因此，我的理解：&nbsp; &nbsp; &nbsp; &nbsp; 0.我把函数的执行，理解为函数名是函数执行的开关，函数名()就会打开这个开关，“触发”函数。&nbsp; &nbsp; &nbsp; &nbsp; 1.函数的执行、变量的取值均是一种“触发”；即函数名(),直接引用变量名，这些均是对函数及变量的“触发”。&nbsp; &nbsp; &nbsp; &nbsp; 2.但是函数和变量不同，函数的执行是函数名()，函数名即为变量(我称变量为容器)，仅是存储函数的容器（实际上存放的是函数的指针，即函数的快捷方式），请看下述代码        (function() {            function foo() {                var a = 2;                function bar() {                    console.log(a)                }                return bar;            }            console.log(foo); //函数foo            console.log(window.foo); //undefined            foo = 12;            console.log(foo) //12            console.log(window.foo); //undefined        })();&nbsp;说明foo可以被赋值，且不是window对象的属性，故可以断定foo就是一个变量(容器)，当然，其实学过C语言或者其他语言的都是知道这一点的，我仅是为了更加确定而已。&nbsp; &nbsp; &nbsp; &nbsp; 3.因此，我说函数的“触发“需要两个条件：函数名和()。()会自动找到变量内的函数并执行        //闭包的深度解析        function foo() {            var a = 2;            function bar() {                console.log(a)            }            return bar;        }        foo()(); //2        var baz = foo(); //2        baz();&nbsp;在这段代码中，bar仅仅是一个存放函数的变量，执行函数foo后会返回bar变量。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.现在拉回来，由于JavaScript是词法作用域，函数的执行，其执行的作用域是在函数定义的作用域气泡内。&nbsp; &nbsp; &nbsp; &nbsp; 5.即函数foo是把bar函数的“触发”开关返回到了外面。外面使用()执行了foo内函数bar，接着就是正常词法作用域的操作了。        function setupBot(name, selector) {            $(selector).click(function activator() {                console.log(\'Activating\' + name);            })        }        setupBot(\'Closure Bot 1\', \'#bot_1\')理解到这里，上面这段代码之所以是闭包，原因即是，内部回调函数的执行是由外部的setupBot控制的。&nbsp; &nbsp; &nbsp; &nbsp; 6.解释下循环和闭包        for (var i = 1; i &lt;= 5; i++) {            // var j = i;            setTimeout(function timer() {                console.log(j)            }, i * 1000);        }这里仅有两级作用域，全局作用域(for循环内)和回调函数内的作用作用域，根据词法作用域规则，回调函数作用域会共享全局作用域，故最终都会输出6        for (var i = 1; i &lt;= 5; i++) {            (() =&gt; {                var j = i;                setTimeout(function timer() {                    console.log(j)                }, i * 1000);            })();        }这里使用了立执行函数(ES6语法)，因此，此时有三级作用域，即全局作用域(for内)、立执行函数的作用域、回调函数的作用域。详细解释下：每次迭代会有5个立执行函数作用域同级和5个回调函数作用域同级，且分别是包含关系故每次迭代时定义的 j 变量分别属于5个立执行函数的作用域，就是说没有 j 的进行数据存储的话，回调函数会由词法作用域规则向上冒泡查找i，这样还是输出5个6        for (var i = 1; i &lt;= 5; i++) {            ((j) =&gt; {                setTimeout(function timer() {                    console.log(j)                }, j * 1000);            })(i);        }这个改进之后的代码，事实上说明了，函数的每次执行，参数都会进行一次绑定。和使用let很像        for (let i = 1; i &lt;= 5; i++) {            setTimeout(function timer() {                console.log(i)            }, i * 1000);        }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.模块和闭包连用。模块就是一个封闭函数返回了一个对象(函数本质也是对象)，因此模块内部形成闭包，故可以通过返回的对象对模块内部持续引用，进行操作。        var foo = (function CoolModule(id) {            function change() {                //修改公共API                publicAPI.identify = identify2;            };            function identify1() {                console.log(id);            };            function identify2() {                console.log(id.toUpperCase());            };            var publicAPI = {                change: change,                identify: identify1            };            return publicAPI; //返回模块        })(\'foo module\');        //此时foo对其模块内部持续引用        //故下述方法执行了模块内部的函数        foo.identify();        foo.change();        foo.identify();&nbsp; 理解了闭包之后，理解模块变得轻而易举。上述代码没啥说的，就是模块产生了闭包，然后对模块内部的持续引用，进行的一些操作。8.书中 现代模块机制 的一个代码案例        //现代的模块机制        var MyModules = (function Manager() {            var modules = {};            function define(name, deps, impl) {                for (var i = 0; i &lt; deps.length; i++) {                    deps[i] = modules[deps[i]];                };                modules[name] = impl.apply(impl, deps);            };            function get(name) {                return modules[name];            };            return {                define: define,                get: get,            }        })();        MyModules.define(\'bar\', [], function() {            function heool(who) {                return \'Let me introduce: \' + who;            };            return { //返回的是对象                heool: heool            };        });        MyModules.define(\'foo\', [\'bar\'], function() {            var hungry = \'hippo\';            function awesome() {                console.log(bar.hello(hungry).toUpperCase());            };            return { //返回的是对象                awesome: awesome            };        });        var bar = MyModules.get(\'bar\');        var foo = MyModules.get(\'foo\');        console.log(bar.hello(\'hippo\')); //Let me introduce:hippo        foo.awesome();&nbsp;其实挺好理解的，就是有点绕：&nbsp; &nbsp; &nbsp; &nbsp; 先说defined函数:一个参数name是会给modules添加一个属性，第二个参数deps就是对modules的属性遍历，并且将遍历的东西传入到第三个参数impl(回调函数)，第三个参数也会变成modules的属性。&nbsp; &nbsp; &nbsp; &nbsp; 再说get函数：就是简单的获取moduls的属性这里说一下代码中第一次执行MoModules.define()时传入了一个空数组，显然modules获取不到属性，则下面的impl.apply()传入的deps就是空了；也就是说apply的第二个参数是一个空，apply的第二个参数是传递给原函数的，即是第一次执行的时候，回调函数内没有传值。第二次同理。当然，还是需要自己认真体会代码的。9.关于附录C&nbsp; this词法的一些理解&nbsp; &nbsp; &nbsp; &nbsp; 在setTimeout中this指向了window，官网给出的答案是：由setTimeout()调用的代码运行在与所在函数完全分离的执行环境上在我看来，obj.cool是指向了cool函数，js引擎在执行obj.cool()时，是一种obj修饰的调用；由此foo也指向了cool函数，故此时foo是对cool函数的直接引用，foo()执行时是不加修饰的调用；因此，我认为setTimeout的参数就是相当于foo一样，是对cool函数的不加修饰的调用。        //附录C  this词法        var obj = {            id: \'awesome\',            cool: function coolFn() {                console.log(this.id);                // console.log(this);            }        };        var id = \'not awesome\';        obj.cool(); //awesome        //this的绑定取决于调用位置，故这里是对coolFn函数的直接引用，即直接调用        var foo = obj.cool;        foo(); //not awesome        // 可见这里也是直接引用        setTimeout(obj.cool, 100); //not awesome        // console.log(window.id)本章知识点：&nbsp; &nbsp; &nbsp; &nbsp; 1.基本都是难点，要记得不多，但均需要理解。&nbsp; &nbsp; &nbsp; &nbsp; 2.模块模式的必要条件：&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ①必须由外部的粉笔函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）。&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ②封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。&nbsp; &nbsp; &nbsp; &nbsp; 3.模块文件中的内容会被当做包含在作用域闭包中一样处理。类似于函数闭包模块.第二部分&nbsp; this和对象模型第1章&nbsp; 关于this本章就是讲了一些对this的误区我认为的本章难点：无书中本章知识点：&nbsp; &nbsp; &nbsp; &nbsp; 1.为什么要使用this？this提供了一种更简洁且易于复用的API设计，我们可以通过更改this指向，隐式的“传递”一个对象的引用。&nbsp; &nbsp; &nbsp; &nbsp; 2.this不指向自身。        // 关于this        function foo(num) {            console.log(\'foo: \' + num);            //记录foo被调用的次数            this.count++;        };        foo.count = 0;        var i = null;        for (i = 0; i &lt; 10; i++) {            if (i &gt; 5) {                foo(i);            }        }        console.log(foo.count); //0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.this在任何情况下都不指向函数的词法作用域，作用域存在于JavaScript引擎内部。&nbsp; &nbsp; &nbsp; &nbsp; 4.经典的this错误，它试图跨越边界        var obj = {}        function foo() {            var a = 2;            this.bar();        }        function bar() {            // LHS查询对象的时候貌似会自动创建属性，应该时新改的。            console.log(this.a); //undefined            console.log(obj.a); //undefined        }        // this.foo(); //undefined        //我觉得定义在全局作用域的函数也会成为全局对象的属性        foo();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.this的绑定和函数的声明位置没有任何关系，只取决于函数的调用方式&nbsp;.即this实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。第2章&nbsp; this全面解析本章就是说了this的指向的规则，及怎么修改this指向，我认为的本章难点：&nbsp; &nbsp; &nbsp; &nbsp; 1.书中的MDN的bind实现，最后的部分没看懂      if (!Function.prototype.bind) { //检擦Function的原型是否有bind方法            Function.prototype.bind = function(OThis) { //定义bind方法                if (typeof this !== \'function\') { //检查调用者是否是函数                    //与 ECMAScript 5最接近的                    //内部 IsCallacle 函数                    throw new TypeError( //如果不是函数，则抛出一个错误，这个函数会停止后续代码的执行                        \'Function.prototype.bind - what is trying\' +                        \'to be bound is not callable\'                    );                };                //分割bind函数的参数，slice可以分割arguments这个伪数组，1代表从第2个索引开始分割arguments                var aArgs = Array.prototype.slice.call(arguments, 1),                    fToBind = this, //bind调用者                    fNOP = function() {}, //                    fBound = function() {                        return fTobind.apply(                            (                                this instanceof fNOP //fNOP的原型链是否在this原型链上                                &amp;&amp;                                OThis ? this : OThis //oThis是否存在                            ),                            aArgs.concat(                                Array.prototype.slice.call(arguments)                            )                        );                    };                fNOP.prototype = this.prototype;                fBound.prototype = new fNOP();                return fBound;            }        }&nbsp; &nbsp; &nbsp; &nbsp; 2.书中软绑定源码，我现在还没能完全理解        //软绑定        if (!Function.prototype.softBind) {            Function.prototype.softBind = function(obj) {                var fn = this;                //捕获所欲curried参数                var curried = [].slice.call(arguments, 1);                var bound = function() {                    return fn.apply(                        (!this || this === (window || global)) ?                        obj : this,                        curried.concat.apply(curried, arguments)                    );                };                bound.prototype = Object.create(fn.prototype);                return bound;            }        }        function foo() {            console.log(\'name: \' + this.name);        }        var obj = {                name: \'obj\'            },            obj2 = {                name: \'obj2\'            },            obj3 = {                name: \'obj3\'            };        var fooOBJ = foo.softBind(obj); //绑定到了obj上        fooOBJ(); //name:obj        obj2.foo = foo.softBind(obj);//绑定到obj上        obj2.foo(); //name:obj2，貌似和隐式绑定差不多        fooOBJ.call(obj3); //name:obj3        setTimeout(obj2.foo, 100); //name:obj&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3.箭头函数会捕获调用上级函数的this，且无法修改。箭头函数可以像bind一样确保函数的this被绑定到指定对象，实质是使用词法作用域取代了this机制，内部有类似于var self = this;这句代码&nbsp; &nbsp;        //箭头函数        function foo() {            //返回一个箭头函数            return (a) =&gt; {                //this继承自foo()                console.log(this.a)            }        }        var obj1 = {            a: 2        };        var obj2 = {            a: 3        };        var bar = foo.call(obj1);        bar.call(obj2); //2本章重要知识点：&nbsp; &nbsp; &nbsp; &nbsp; 1.调用位置就是函数在代码中被调用的位置（而不是声明位置）。需要分析调用栈。&nbsp; &nbsp; &nbsp; &nbsp; 2.函数运行在“非严格模式”下，函数会执行默认绑定；但在严格模式下调用函数，则不影响函数的默认绑定 。区分一下运行和调用。默认绑定就是全局函数默认绑定到全局对象上。&nbsp; &nbsp; &nbsp; &nbsp; 3.当函数引用有上下文对象时，隐式绑定规则会把函数调用中的this绑定到这个上下文对象。对象的属性引用链中只有上一层或者说最后一层在调用位置中起作用        function foo() {            console.log(this.a)        }        var obj2 = {            a: 42,            foo: foo        }        var obj1 = {            a: 2,            obj2: obj2        }        obj1.obj2.foo(); //42&nbsp; &nbsp; &nbsp; &nbsp; 3.&nbsp;隐式绑定造成this丢失的实质是对一个函数的直接引用（不带任何修饰的函数调用）&nbsp; &nbsp; &nbsp; &nbsp; 4.回调函数的函数可能会修改this，流行的JavaScript库中事件处理器常会把回调函数的this强制绑定到触发事件的DOM元素上。我是用jQuery发现并没有像后半句所说的那样        window.addEventListener(\'load\', function() {            console.log(this); //window            document.querySelector(\'p\').addEventListener(\'click\', function(e) {                function foo() {                    console.log(this); //window                }                foo();                //这里就是绑定到触发的DOM元素上                console.log(this); //p                console.log(e.target); //p            })        })        $(function() {            console.log(this); //#document,貌似是jQuery的文档对象            $(\'p\').on(\'click\', function(e) {                function foo() {                    console.log(this); //window                }                foo();                console.log(this); //p                console.log(e.target); //p            })        })&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.硬绑定call和apply2。硬绑定就是使用新函数对call和apply语句进行了隔离。        //硬绑定，        function foo() {            console.log(this.a)        }        var obj = {            a: 2,            foo: foo        };        var a = 3;        var bar = function() {            // foo();            return foo.call(obj); //2        };        bar();        setTimeout(bar, 100); //2        //硬绑定的bar不可能再修改它的this。        //上面这句和废话一样，bar现在是一个新函数，这些操作均是对新函数的操作，怎么会修改foo的this        bar.call(window); //2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.new操作符调用的是普通函数，即所有函数均可使用new调用。不存在所谓的”构造函数“，只有对于函数的”构造调用“，new的操作：&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.创建（或者说构造）一个全新的对象&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.这个新对象会被执行[[Prototype]]连接&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3.这个新对象会被绑定到函数调用的this&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4.如果函数没有返回其他对象，那么new表达式的函数调用会自动返回这个新对象&nbsp;        function foo(a) {            this.a = a;        }        var bar = new foo(2);        //返回了一个新对象，因此可以bar.a访问新对象的属性        console.log(bar.a); //2&nbsp; &nbsp; &nbsp; 7.判断this：&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ①函数是否在new中调用(new 绑定)？如果是的话this绑定的是新创建的对象。&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var&nbsp; bar = new foo();&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ②函数是否通过call、apply（显示绑定）或着硬绑定调用?如果是的话，this绑定的是指定的对象。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp; bar&nbsp;= foo.call(obj2)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ③函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this绑定的是那个上下文对象。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var bar =obj1.foo();&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ④如果均不是的话，使用默认绑定。如果严格模式下，就绑定到undefined，否则绑定到全局对象。&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var&nbsp; bar&nbsp; =&nbsp; foo();&nbsp; &nbsp; &nbsp; &nbsp; 8.柯里化：把除了第一个参数（第一个参数用于绑定this）之外的其他参数都传给下层的函数（这种技术称为”部分应用“，是“柯里化”的一种）&nbsp; &nbsp; &nbsp; &nbsp; 9.JavaScript中创建一个空对象最简单的方法都是object.create(null)。这么做不会创建object.prototype这个委托，比{}“更空”。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.对于默认绑定来说，决定this绑定对象的并不是调用位置是否处于严格模式，而是函数体是否处于严格模式。&nbsp; &nbsp; &nbsp; &nbsp; 11.硬绑定会大大降低函数的灵活性，使用硬绑定之后就无法使用隐式绑定或者显示绑定来修改this。第3章&nbsp; 对象有一种常见的说法“JavaScript中万物皆是对象”，这显然是错误的。本章就是讲了对象的一些操作：创建、配置、封印本章难点：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.Symbol.iterator：为每一个对象定义了默认的迭代器。该迭代器可以被 for-of&nbsp;循环使用。for-of会找内置的@@iterator对象并调用next()方法来遍历数据        //自定义对象迭代器        var myObject = {            a: 2,            b: 3        };        Object.defineProperty(myObject, Symbol.iterator, {                enumerable: false,                writable: false,                configurable: true,                value: function() {                    var o = this;                    var idx = 0;                    var ks = Object.keys(o);                    return {                        next: function() {                            return {                                value: o[ks[idx++]],                                done: (idx &gt; ks.length)                            };                        }                    };                }            })            //手动遍历myObject        var it = myObject[Symbol.iterator]();        console.log(it.next()); //{value:2,done:false}        console.log(it.next()); //{value:3,done:false}        console.log(it.next()); //{value:undefined,done:true}        //for-of遍历        for (var v of myObject) {            console.log(v)        }; //2,3&nbsp;代码的意思就是定义了一个Symbol.iterator属性，这个属性的value是个函数，函数内部有各种操作。文字表达起来有点费劲，可以尝试运行代码自行体会本章知识点：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.JavaScript的六种主要类型：string，number，boolean，null，undefined，object。&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typeof&nbsp; null;之所以返回Object，是因为JavaScript中二进制前三位均为0，就会被判定为object类型，而null的二进制表示全为0，自然被判定为object了&nbsp; &nbsp; &nbsp; &nbsp; 2.内置对象：String，Number，Boolean，Object，Function，Array，Date，RegExp，Error。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.JavaScript会自动将字符串，数字等使用方法时，会转换为内置对象，如‘I am string’，实际上会进行new String(‘I am string’)&nbsp; &nbsp; &nbsp; &nbsp; 4.在对象中，属性名永远是字符串，如果你使用string（字面量，字符串的存储是固定的）以外的其他值作为属性名，那它首先会被转换为一个字符串；&nbsp; &nbsp; &nbsp; &nbsp; 5.数组也是对象，因此可以给数组添加属性，但是如果试图给数组添加一个类数字属性，进行键访问的时候，此属性会变成一个数值下标        var myArray = [\'foo\', \'turnip\', 43];        myArray[\'3\'] = \'kkk\';        myArray.length; //4        myArray[3]; //43&nbsp; &nbsp; &nbsp; &nbsp; 6.Object.defineProperty官方描述：Object.defineProperty。该方法可以配置对象        \'use strict\' //修改只读属性，会报错        var myObject = {};        Object.defineProperty(myObject, \'a\', {            value: 2,            writeable: false, //不可写,只读            configurable: true, //可配置的            enumerable: true //可枚举        });        myObject.a = 3;        console.log(myObject.a); //2&nbsp; &nbsp; &nbsp; &nbsp; 7.结合 writeable:false和configurable:false 就可以创建一个真正的常量属性(不可修改、重定义或删除)        var myObject = {};        Object.defineProperty(myObject, \'FAVORITE_NUMBER\', {            value: 42,            writable: false,            configurable: false        })&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;8.Object.preventExtensions官方解释：Object.preventExtensions。该方法可以让一个对象变的不可扩展，也就是永远不能再添加新的属性。        var myObject = {            a: 2        };        Object.preventExtensions(myObject);        myObject.b = 3;        console.log(myObject.b); //undefined&nbsp; &nbsp; &nbsp; &nbsp; 9.Object.seal()官方解释：Object.seal。该方法封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置、不可删除。当前属性的值只要原来是可写的就可以改变。&nbsp; &nbsp; &nbsp; &nbsp; 10.Object.freeze()官方解释：Object.freeze()。这个方法是可以应用在对象上的级别对高的不可变性。&nbsp; &nbsp;11.getter和setter均是一个隐藏函数，前者获取属性时调用，后者设置属性时调用。        var myObject = {            //给a定义一个getter            get a() {                return this._a_;            },            set a(val) {                this._a_ = val * 2;            }        }        myObject.a = 2;        console.log(myObject.a);//4        console.log(myObject._a_); //4，创建了一个属性&nbsp; &nbsp; &nbsp; &nbsp; 11可枚举 就相当于 可以出现在对象属性的遍历中。for-in会静默，但是for循环可以。&nbsp; &nbsp; &nbsp; &nbsp; propertyIsEnumerable()会检查给定的属性名是否直接存在于对象中（而不是原型链上）并且满足enumerable：true&nbsp; &nbsp; &nbsp; &nbsp; Object.keys()会返回一个数组，包含所有可枚举的属性，Object,getOwnpropertyNames()会返回一个数组，包含所有属性，无论他们是否可枚举；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object.prototype.hasOwnProperty和in的区别在于是否查找[[Prototype]]链&nbsp; &nbsp; &nbsp; &nbsp; object.keys()和Object.getOwnPropertyNames()都只会查找对象直接包含的属性        var myObject = {};        Object.defineProperty(myObject, \'a\',            //让a像普通属性一样可以枚举            {                enumerable: true,                value: 2            });        Object.defineProperty(myObject, \'b\',            //让a像普通属性一样可以枚举            {                enumerable: false,                value: 2            });        console.log(myObject.b); //3        console.log((\'b\' in myObject)); //true        console.log(myObject.hasOwnProperty(\'b\')); //true        for (var key in myObject) {            console.log(key, myObject[key]);        }; //\'a\' 2        console.log(myObject.propertyIsEnumerable(\'a\')); //true        console.log(myObject.propertyIsEnumerable(\'b\')); //false        console.log(Object.keys(myObject)); //[\'a\']        console.log(Object.getOwnPropertyNames(myObject)); //[\'a\',\'b\']第4章&nbsp; 混合对象 “类”只要理解了this指向和对象，这一章的内容理解起来很容易，都是一些概念而已。本章难点：&nbsp; &nbsp; &nbsp; &nbsp; 1.多态就是任何方法均可以引用继承层次中高层的方法，及继承使得方法可以在多类中映射。&nbsp; &nbsp; &nbsp; &nbsp; 2.显示多态就是把显示的将父类的方法引入子类，但此时方法显示绑定的对象是子类本章知识点：&nbsp; &nbsp; &nbsp; &nbsp; 1.类/继承描述了一种代码的住址结构——一种在软件中对真实世界中问题领域的建模方法，面向对象编程强调的是数据和操作数据的行为本质上是互相关联的。&nbsp; &nbsp; &nbsp; &nbsp; 2.JavaScript中并没有类，JavaScript只是提供了一些近似类的语法，因此JavaScript的类是一种设计模式(类本身就是一种设计模式)。如ES6的class&nbsp; &nbsp; &nbsp; &nbsp; 3.类实例是由一个特殊的类方法构造的，这个方法名通常和类同名，被称为构造函数。&nbsp; &nbsp; &nbsp; &nbsp; 4.类的继承其实就是复制第5章&nbsp; 原型原型的实质就是对象之间的关联关系。本章难点：&nbsp; &nbsp; &nbsp; &nbsp; 1.原型的本质就是一种关联关系，原型链就是关联树，即JavaScript引擎会查找原型链        var anotherObject = {            a: 2        };        //创建一个关联到anotherObject的对象        var myObject = Object.create(anotherObject);        //注意此时myObject.a并不存在，但是JavaScript引擎会在原型链上查找该属性        console.log(myObject.a); //2&nbsp; &nbsp; &nbsp; &nbsp; 2.隐式屏蔽        var anotherObject = {            a: 2        };        var myObject = Object.create(anotherObject);        console.log(anotherObject.a); //2        console.log(myObject.a); //2        console.log(anotherObject.hasOwnProperty(\'a\')); //true        console.log(myObject.hasOwnProperty(\'a\')); //false        console.log(anotherObject);        console.log(myObject); //属于anotherObject下一级        myObject.a++; //myObject.a= myObject.a + 1        console.log(anotherObject.a); //2        console.log(myObject.a); //3        console.log(myObject.hasOwnProperty(\'a\')); //true&nbsp; &nbsp; &nbsp; &nbsp; 3.new的关联，new的操作，就是创建了一个关联到其他对象的新对象。实际上我们并没有复制“类“，只是让他们关联而已        function Foo() {}        var a = new Foo();        //new操作后，都会被关联到Foo.prototype对象上        console.log(Object.getPrototypeOf(a) === Foo.prototype); //true本章知识点：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.使用for-in&nbsp;遍历对象时原理和查找[[Prototype]]链类似，任何可以通过原型链访问到的属性都会被枚举。使用in操作符来检查属性在对象中是否存在时，同样会查找对象的整条原型链。&nbsp; &nbsp; &nbsp; &nbsp; 2.所有普通的[[Prototype]]链最终都会指向内置的Object.prototype。&nbsp; &nbsp; &nbsp; &nbsp; 3.函数不是构造函数，但当且仅当使用new时，函数调用会变成”构造函数调用“。&nbsp; &nbsp; &nbsp; &nbsp; 4.Object.create()会创建一个新对象，并把它关联到我们指定的对象上        //兼容的Object.create        if (!Object.create) {            Object.create = function(o) {                function F() {}; //声明空函数                F.prototype = o;                return new F();            }        }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5.内部委托。避免明明当前对象没有这个属性，但是却神奇的可以调用。也使得API设计更加清晰        var anotherObject = {            cool: function() {                console.log(\'cool!\');            }        }        var myObject = Object.create(anotherObject);        myObject.doCool = function() {            this.cool(); //内部委托        }        myObject.doCool();第6章&nbsp; 行为委托这一章没什么可说的，就是对委托这种设计模式的讲解，理解了this机制、对象、原型之后，书中的代码也并没有什么难点。知识回顾：&nbsp; &nbsp; &nbsp; &nbsp; 1.如果在第一个对象上没有找到需要的属性或者方法引用，JavaScript引擎会继续在[[Prototype]]关联的对象上进行查找。&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 2.JavaScript的原型链机制的本质就是对象与对象之间的关联关系。本章难点：&nbsp; &nbsp; &nbsp; &nbsp; 1.类理论和委托理论的对比：        //类理论(伪代码)        class Task {            id;            //函数Task()            Task(ID) {                id = ID;            }            outputTask() {                output(id);            }        };        class XYZ inherits Task {            label;            //构造函数XYZ            XYZ(ID, Label) {                super(ID);                label = Label;            }            outputTask() {                super();                output(label);            }        };        class ABC inherits Task {            //...        };        //委托理论        Task = {            setID: function(ID) {                this.id = ID;            },            output: function() {                console.log(this.id)            }        };        // 让XYZ委托给Task        XYZ = Object.create(Task);        XYZ.prepareTask = function(ID,Label){            this.setID(ID);            this.label = Label;        }        XYZ.outputTaskDetails = function(){            this.outputID();            console.log(this.label);        };        //ABC = Object.create(Task);        //ABC ... = ...可以看出，类理论：当实例化子类时，子类的实例会复制父类和子类的行为&nbsp;。&nbsp;可参考java类原理&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 委托理论：”子类“(对象)通过[[Prototype]]委托给了”父类“，当调用子类中没有的方法时，会通过委托关系查找关联的对象，又由于调用位置触发this的隐式绑定规则，故this的绑定仍是”子类“，而这正是我们想要的结果。由此看来委托的设计模式更加简洁。&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;本章知识点：&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 无','JavaScript','/page3','2021-08-06 21:09:03','32398','0','20','0','Windows','Edge',1),(4,'./T_Image/articleImg/hzw2.jpeg','第四篇--浅析JavaScript的this绑定','<h1 style=\"text-align:center;\" id=\"dre35\">第四篇--浅析JavaScript的this绑定</h1><p>JavaScript的this指向有四种绑定规则，即：</p><p>1.默认绑定</p><p>2.隐式绑定</p><p>3.显示绑定</p><p>4.new调用绑定</p><p style=\"padding-left:2em;\"><strong><font color=\"#c24f4a\">默认绑定：即全局函数的this默认绑定到window</font></strong></p><p>\n</p><pre><code>    var a = 3;//var会连接到window对象\n    let foo = function () {\n      console.log(this.a);\n    }\n    foo();//3</code></pre><p>\n\n\n\n\n\n\n\n\n\n\n\n\n<img src=\"data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==\"/></p><p style=\"padding-left:2em;\"><strong><font color=\"#c24f4a\">隐式绑定：即函数在上下文对象内则绑定到上下文对象上。下转隐式丢失对比理解</font></strong></p><p>\n</p><pre><code>    var a = 3;\n    let obj = {\n      a: 2,\n      foo() {\n        console.log(this.a);\n      }\n    };\n    obj.foo();//2\n    // 或\n    function foo() {\n      console.log(this.a);\n    };\n    let obj = {\n      a: 2,\n      foo: foo\n    };\n    obj.foo();//2</code></pre><p>\n\n\n\n\n<img src=\"data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==\"/></p><p><strong>提一嘴隐式丢失：官方解释bar是对foo不加修饰的调用，因此丢失了obj的绑定。</strong></p><p>我的理解就是，obj.foo在执行时，是通过obj对象查询到foo并进行了调用；而bar是将foo的指针取了出来，bar得到了foo的指针，因此bar()等同于foo();</p><p>\n</p><pre><code>    var a = 3;\n    function foo() {\n      console.log(this.a);\n    };\n    let obj = {\n      a: 2,\n      foo: foo\n    };\n    obj.foo();//2\n    let bar = obj.foo;\n    bar();//3,丢失了obj</code></pre><p>\n\n\n\n\n\n\n<img src=\"data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==\"/></p><p style=\"padding-left:2em;\"><strong><font color=\"#c24f4a\">显示绑定：即通过call、apply方法显示绑定this。</font></strong></p><p>\n</p><pre><code>    var a = 3;\n    function foo() {\n      console.log(this.a);\n    }\n    let obj = {\n      a: 2\n    }\n    foo.call(obj);//2\n    foo.apply(obj);//2</code></pre><p>\n\n\n\n\n<img src=\"data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==\"/></p><p>显示绑定没有解决隐式丢失问题，即foo的绑定还是丢失了。我们需要的是具有foo功能的函数，但是这个函数已经硬硬的绑定到了我们所给的对象上了。</p><p><strong>显示绑定之硬绑定：硬硬的的绑定到我们所给的对象上，实际上就是多包裹了一层函数</strong></p><p>\n</p><pre><code>    function foo() {\n      console.log(this.a);\n    }\n    var obj = {\n      a: 2\n    }\n    var bar = function () {\n      foo.call(obj);\n    }\n    bar();//2\n    bar.call(window);//2</code></pre><p>\n\n\n\n\n\n\n<img src=\"data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==\"/></p><p>bind的实现原理有部分类似于此</p><p style=\"padding-left:2em;\"><strong><font color=\"#c24f4a\">new调用绑定:构造调用，构造调用的函数会出现4种变化</font></strong></p><p>①创建（构造）一个全新的对象</p><p>②这个对象会被直行[[Prototype]]链接</p><p>③这个新对象会被绑定到函数调用的this</p><p>④如果函数没有返回其他对象，则new表达式中的函数调用会自动返回这个新对象</p><p>明确一点，new不是实例化类，而是调用一个新函数，只是和普通调用不同，这里是构造调用，详解见官网</p><p>\n</p><pre><code>    function foo() {\n      this.a = a;\n    }\n    //即此时new调用会创建一个新对象，并返回，即此时bar就是new调用所建的新对象了\n    var bar = new foo(2);\n    console.log(bar.a);//2</code></pre><p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<img src=\"data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==\"/></p><p><strong><font color=\"#c24f4a\">四中绑定的优先级：new &gt;&nbsp;显示 &gt; 隐式 &gt;&nbsp;默认绑定</font></strong></p><p>\n\n\n<br/></p>','JavaScript的this指向有四种绑定规则，即：1.默认绑定2.隐式绑定3.显示绑定4.new调用绑定默认绑定：即全局函数的this默认绑定到window隐式绑定：即函数在上下文对象内则绑定到上下文对象上。下转隐式丢失对比理解提一嘴隐式丢失：官方解释bar是对foo不加修饰的调用，因此丢失了obj的绑定。我的理解就是，obj.foo在执行时，是通过obj对象查询到foo并进行了调用；而bar是将foo的指针取了出来，bar得到了foo的指针，因此bar()等同于foo();显示绑定：即通过call、apply方法显示绑定this。显示绑定没有解决隐式丢失问题，即foo的绑定还是丢失了。我们需要的是具有foo功能的函数，但是这个函数已经硬硬的绑定到了我们所给的对象上了。显示绑定之硬绑定：硬硬的的绑定到我们所给的对象上，实际上就是多包裹了一层函数bind的实现原理有部分类似于此new调用绑定:构造调用，构造调用的函数会出现4种变化①创建（构造）一个全新的对象②这个对象会被直行[[Prototype]]链接③这个新对象会被绑定到函数调用的this④如果函数没有返回其他对象，则new表达式中的函数调用会自动返回这个新对象明确一点，new不是实例化类，而是调用一个新函数，只是和普通调用不同，这里是构造调用，详解见官网四中绑定的优先级：new &gt;&nbsp;显示 &gt; 隐式 &gt;&nbsp;默认绑定','JavaScript','/page4','2021-08-09 20:36:05','637','0','109','0','Windows','Edge',1),(5,'./T_Image/articleImg/default.jpeg','第五篇--浅析javascript中的混合对象“类”','<p style=\"text-align:center;\"><b><span style=\"font-size: 32px;\">浅析JavaScript中的混合对象“类”</span></b></p><p><strong>&nbsp;这里浅析的是《你不知道的JavaScript 上卷》中的混合对象“类”</strong></p><p>类就是一个解决问题的蓝图，实例化类就是把蓝图构建出来。</p><p><strong>构造函数</strong>：类中均会有一个构造函数，构造函数的作用就是，当实例化类时，会调用这个函数，可以理解为类的入口。</p><p><strong>类的继承</strong>：即子类会继承父类的行为。</p><p><strong>多态</strong>：即类继承之后的引用，会根据类的实例化来决定，就是当父类和子类定义相同的方法时，对于方法的使用取决于实例的类是哪个。多态并非是子类和父类有关联，而是子类得到了父类的副本，即类的继承就是复制。</p><p><strong>多重继承</strong>：子类可以继承多个父类。</p><p>JavaScript中只有对象，并不存在实例化类。</p><p><strong>显示混入</strong>：即是直接显示的进行对象复制。</p><p>\n</p><p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n</p><pre><code class=\"JavaScript\">    <span class=\"hljs-comment\">//相当于实现实例化类的函数，实际上就是一种复制</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">mixin</span><span class=\"hljs-params\">(sourceObj, targetObj)</span> {</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> key <span class=\"hljs-keyword\">in</span> sourceObj) {\n        <span class=\"hljs-comment\">//对不存在的情况进行复制</span>\n        <span class=\"hljs-keyword\">if</span> (!key <span class=\"hljs-keyword\">in</span> targetObj) {\n          targetObj[key] = sourceObj[key];\n        }\n      }\n      <span class=\"hljs-keyword\">return</span> targetObj;\n    };\n    <span class=\"hljs-keyword\">var</span> Vehicle = {\n      engines: <span class=\"hljs-number\">1</span>,\n      ignition: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">()</span> {</span>\n        console.log(<span class=\"hljs-string\">\'Turning on my engine.\'</span>);\n      },\n      drive: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">()</span> {</span>\n        <span class=\"hljs-keyword\">this</span>.ignition();\n        console.log(<span class=\"hljs-string\">\'Steering and moving forward!\'</span>);\n      }\n    };\n    <span class=\"hljs-keyword\">var</span> Car = mixin(Vehicle, {\n      wheels: <span class=\"hljs-number\">4</span>,\n      drive: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">()</span> {</span>\n        Vehicle.drive.call(<span class=\"hljs-keyword\">this</span>);\n        console.log(<span class=\"hljs-string\">\'Rolling on all\'</span> + <span class=\"hljs-keyword\">this</span>.wheels + <span class=\"hljs-string\">\'Wheels!\'</span>)\n      }\n    })</code></pre><p>混合复制：即先把父类复制进一个空对象A内从而得到子类（对象B），再把新内容传入子类（对象B）</p><p>寄生继承：即直接在函数中new父类得到对象A，然后对A进行重写并返回。</p><p><strong>隐式混入：利用显示的this指向，将this指向到子类的上下文。</strong></p><p>\n</p><p>\n\n\n\n\n\n\n\n\n<img src=\"data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==\"/></p><pre><code class=\"JavaScript\">    <span class=\"hljs-keyword\">var</span> something = {\n      cool: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">()</span> {</span>\n        <span class=\"hljs-keyword\">this</span>.greeting = <span class=\"hljs-string\">\'Hello World!\'</span>;\n        <span class=\"hljs-keyword\">this</span>.count = <span class=\"hljs-keyword\">this</span>.count ? <span class=\"hljs-keyword\">this</span>.count + <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">1</span>;\n      }\n    };\n    something.coll();\n    something.greeting;<span class=\"hljs-comment\">//Hello World!</span>\n    something.count;<span class=\"hljs-comment\">//1</span>\n    <span class=\"hljs-keyword\">var</span> Another = {\n      cool: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">()</span> {</span>\n        <span class=\"hljs-comment\">// 隐式将this指向Another，这里cool的this是Another，即显示将something.cool的this指向了Another</span>\n        something.cool.call(<span class=\"hljs-keyword\">this</span>);\n      }\n    }\n    Another.cool();\n    Another.greeting;<span class=\"hljs-comment\">//Hello World!</span>\n    Another.count;<span class=\"hljs-comment\">//1(非共享的something)</span></code></pre><p><br/>\n</p><p>\n\n\n<br/></p>','浅析JavaScript中的混合对象“类”&nbsp;这里浅析的是《你不知道的JavaScript 上卷》中的混合对象“类”类就是一个解决问题的蓝图，实例化类就是把蓝图构建出来。构造函数：类中均会有一个构造函数，构造函数的作用就是，当实例化类时，会调用这个函数，可以理解为类的入口。类的继承：即子类会继承父类的行为。多态：即类继承之后的引用，会根据类的实例化来决定，就是当父类和子类定义相同的方法时，对于方法的使用取决于实例的类是哪个。多态并非是子类和父类有关联，而是子类得到了父类的副本，即类的继承就是复制。多重继承：子类可以继承多个父类。JavaScript中只有对象，并不存在实例化类。显示混入：即是直接显示的进行对象复制。    //相当于实现实例化类的函数，实际上就是一种复制function mixin(sourceObj, targetObj) {for (var key in//对不存在的情况进行复制if (!key inreturnvar1function () {\'Turning on my engine.\'function () {this\'Steering and moving forward!\'var4function () {this\'Rolling on all\' + this.wheels + \'Wheels!\'混合复制：即先把父类复制进一个空对象A内从而得到子类（对象B），再把新内容传入子类（对象B）寄生继承：即直接在函数中new父类得到对象A，然后对A进行重写并返回。隐式混入：利用显示的this指向，将this指向到子类的上下文。    varfunction () {this.greeting = \'Hello World!\'this.count = this.count ? this.count + 1 : 1//Hello World!//1varfunction () {// 隐式将this指向Another，这里cool的this是Another，即显示将something.cool的this指向了Anotherthis//Hello World!//1(非共享的something)','JavaScript','/page5','2021-08-13 15:09:09','925','0','141','0','Windows','Edge',1);

/*Table structure for table `t_article_copy` */

DROP TABLE IF EXISTS `t_article_copy`;

CREATE TABLE `t_article_copy` (
  `t_id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '文章id',
  `t_picture` varchar(255) DEFAULT './T_Image/articleImg/default.jpeg' COMMENT '文章配图',
  `t_headline` varchar(100) NOT NULL COMMENT '文章标题',
  `t_content` text NOT NULL COMMENT '文章内容',
  `t_text` text COMMENT '文章主要内容',
  `t_tag` varchar(20) NOT NULL DEFAULT '学习' COMMENT '文章标签',
  `t_route` varchar(20) NOT NULL COMMENT '文章路由',
  `t_date` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '写作时间',
  `t_textNumber` varchar(100) DEFAULT NULL COMMENT '文章字数',
  `t_liveNumber` varchar(20) DEFAULT '0' COMMENT '点赞数',
  `t_readNumber` varchar(20) DEFAULT '0' COMMENT '阅读数',
  `t_reviewNumber` varchar(20) DEFAULT '0' COMMENT '评论数',
  `t_writingPlatform` varchar(20) DEFAULT 'windows' COMMENT '写作平台',
  `t_browser` varchar(20) DEFAULT '火狐' COMMENT '浏览器',
  `t_key` int(10) unsigned NOT NULL DEFAULT '1' COMMENT '外键',
  PRIMARY KEY (`t_id`),
  KEY `t_key` (`t_key`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;

/*Data for the table `t_article_copy` */

/*Table structure for table `t_article_copys` */

DROP TABLE IF EXISTS `t_article_copys`;

CREATE TABLE `t_article_copys` (
  `t_id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '文章id',
  `t_picture` varchar(255) DEFAULT './T_Image/articleImg/default.jpeg' COMMENT '文章配图',
  `t_headline` varchar(100) NOT NULL COMMENT '文章标题',
  `t_content` text NOT NULL COMMENT '文章内容',
  `t_text` text COMMENT '文章主要内容',
  `t_tag` varchar(20) NOT NULL DEFAULT '学习' COMMENT '文章标签',
  `t_route` varchar(20) NOT NULL COMMENT '文章路由',
  `t_date` varchar(20) DEFAULT NULL COMMENT '写作时间',
  `t_textNumber` varchar(100) DEFAULT NULL COMMENT '文章字数',
  `t_liveNumber` varchar(20) DEFAULT '0' COMMENT '点赞数',
  `t_readNumber` varchar(20) DEFAULT '0' COMMENT '阅读数',
  `t_reviewNumber` varchar(20) DEFAULT '0' COMMENT '评论数',
  `t_writingPlatform` varchar(20) DEFAULT 'windows' COMMENT '写作平台',
  `t_browser` varchar(20) DEFAULT '火狐' COMMENT '浏览器',
  `t_key` int(10) unsigned NOT NULL DEFAULT '1' COMMENT '外键',
  PRIMARY KEY (`t_id`),
  KEY `t_key` (`t_key`)
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;

/*Data for the table `t_article_copys` */

insert  into `t_article_copys`(`t_id`,`t_picture`,`t_headline`,`t_content`,`t_text`,`t_tag`,`t_route`,`t_date`,`t_textNumber`,`t_liveNumber`,`t_readNumber`,`t_reviewNumber`,`t_writingPlatform`,`t_browser`,`t_key`) values (1,'./T_Image/articleImg/default.jpeg','第一篇--为什么会要做这个博客网站？','<h2 style=\"text-align:center;\" id=\"aprro\">第一篇：为什么会要做这个博客网站？</h2><p style=\"text-align:left\">&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color: rgb(194, 79, 74);\">一次偶然，我发现很多前端，亦或是后端的大学生均建有自己的网站，离谱的是非计算专业的大学生也有，甚至连正在上中学的学生也有。这让我羡慕也让我吃惊，也因此让我也萌生了建网站的想法。</span></p><hr/><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是，也刚好是我学完node.js、Vue.js的时候，大致了解了网站的流程。说干就干，我大致看了他们的网站，大都是使用的UI库。我本想也使用UI库，这样也更快，更好看。但细想下来，这么做对我的技术并不会有什么增长，因此，我决定尽量使用原生的web三剑客去实现我网站的特效、功能。至此，网站的主要功能（<span style=\"background-color: rgb(238, 236, 224);\">文章的编辑后，立即自动化渲染及生成对应路由</span>）已完成。很多并不太重要的功能，我并不准备立即完成。我深知自己的技术功底并不扎实，如这次建站并没有对许多API进行兼容性处理、写的代码很多没有考虑性能问题、代码没有进行压缩等，这些问题我会在未来几天着手优化、解决。也因此网站的后续功能只会缓慢更新，当然，还有就是有很多书需要看，及我也正在准备计算机二级考试和英语四级考试。</p><p><br/></p><p><br/></p><p style=\"text-align:right;\"><u>作者：turnip</u></p><p style=\"text-align:right;\"><i>2021年7月31日</i></p><p style=\"text-align:right;\"><i><br/></i></p><p style=\"text-align:right;\"><i><br/></i></p>','一次偶然，我发现很多前端，亦或是后端的大学生均建有自己的网站，离谱的是非计算专业的大学生也有，甚至连正在上中学的学生也有。这让我羡慕也让我吃惊，也因此让我也萌生了建网站的想法。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是，也刚好是我学完node.js、Vue.js的时候，大致了解了网站的流程。说干就干，我大致看了他们的网站，大都是使用的UI库。我本想也使用UI库，这样也更快，更好看。但细想下来，这么做对我的技术并不会有什么增长，因此，我决定尽量使用原生的web三剑客去实现我网站的特效、功能。至此，网站的主要功能（文章的编辑后，立即自动化渲染及生成对应路由）已完成。很多并不太重要的功能，我并不准备立即完成。我深知自己的技术功底并不扎实，如这次建站并没有对许多API进行兼容性处理、写的代码很多没有考虑性能问题、代码没有进行压缩等，这些问题我会在未来几天着手优化、解决。也因此网站的后续功能只会缓慢更新，当然，还有就是有很多书需要看，及我也正在准备计算机二级考试和英语四级考试。作者：turnip2021年7月31日','关于网站','/page1','2021-07-31 14:27:27','548','0','73','0','Windows','Edge',1),(2,'./T_Image/articleImg/hzw2.jpeg','第二篇--js的作用域和查询规则解析','<h1 id=\"x4m5c\" style=\"text-align:center;\">第二篇--js的作用域和查询规则解析</h1><p><strong>JavaScript中的作用域是词法作用域，即js引擎的查找规则，遵循代码书写时的作用气泡进行逐级查找。</strong></p><p><strong>这里简述一下LHS查询和RHS查询，即查询词法作用域内赋值操作的左右。详解左转<a href=\"https://blog.csdn.net/qq_26244513/article/details/118088162?spm=1001.2014.3001.5501\">你不知道的JavaScript知识梳理</a></strong></p><p><strong>下面解释一下词法作用域的逻辑</strong></p><p>注意：词法作用域是js引擎查找当前代码片段之前的作用域，请看代码</p><p>\n</p><pre><code class=\"JavaScript\">       <span class=\"hljs-built_in\">console</span>.log(a); <span class=\"hljs-regexp\">//</span><span class=\"hljs-literal\">undefined</span>\n        <span class=\"hljs-reserved\">var</span> a = <span class=\"hljs-number\">3</span>;</code></pre><p>\n\n\n\n\n\n\n\n\n</p><p>此时输出undefined，变量a变量提升到了console.log()之前，当console.log()执行时进行RHS查询，但此时a的赋值操作还未执行到，a的值还没进入到词法作用域内，故此时RHS查询得不到a的值，会输出undefined。</p><p>进而解释，请看代码</p><p>\n</p><p>\n\n\n\n\n\n\n</p><pre><code class=\"JavaScript\">       <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">bar</span><span class=\"hljs-params\">()</span> {</span>\n            console.log(a); <span class=\"hljs-comment\">//3</span>\n        }\n        <span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">3</span>;\n        bar();</code></pre><p>bar()在执行时，a的定义和赋值操作均已执行到，此时a已全部进入到词法作用域，故当函数调用，并执行函数内部的console.log()时，js引擎在其内部进行RHS查询得到了a的值。</p><p><strong>总结：词法作用域就是js引擎在代码逐行编译是各代码词法产生的作用域，故随着代码的编译作用域内部逐渐放大</strong></p><p>\n\n\n\n\n<br/></p>','JavaScript中的作用域是词法作用域，即js引擎的查找规则，遵循代码书写时的作用气泡进行逐级查找。这里简述一下LHS查询和RHS查询，即查询词法作用域内赋值操作的左右。详解左转你不知道的JavaScript知识梳理下面解释一下词法作用域的逻辑注意：词法作用域是js引擎查找当前代码片段之前的作用域，请看代码       console.log(a); //undefinedvar a = 3;此时输出undefined，变量a变量提升到了console.log()之前，当console.log()执行时进行RHS查询，但此时a的赋值操作还未执行到，a的值还没进入到词法作用域内，故此时RHS查询得不到a的值，会输出undefined。进而解释，请看代码       function bar() {//3var a = 3bar()在执行时，a的定义和赋值操作均已执行到，此时a已全部进入到词法作用域，故当函数调用，并执行函数内部的console.log()时，js引擎在其内部进行RHS查询得到了a的值。总结：词法作用域就是js引擎在代码逐行编译是各代码词法产生的作用域，故随着代码的编译作用域内部逐渐放大','JavaScript','/page2','2021-08-02 19:08:54','527','0','13','0','Windows','Edge',1),(3,'./T_Image/articleImg/default.jpeg','第三篇--你不知道的javascript知识梳理','<h1 style=\"text-align:center;\" id=\"lblpi\"><a href=\"https://blog.csdn.net/qq_26244513/article/details/118088162?spm=1001.2014.3001.5501\" target=\"_blank\">你不知道的JavaScript 上卷 知识梳</a></h1><p>完结语：2021年7月2日，终于写完了。我原本是想用一周的时间看完这本上卷的，也是没想到前前后后竟然花了十多天的时间。还好，收获还是挺多的，书中的内容的确让我对JavaScript这门语言有了更深的认识。<br/><br/>这个知识梳理适合那些已经看完了《你不知道的JavaScript&nbsp;上卷》，但仍觉得一头雾水的人，我也看了很多博主写了这本书的知识梳理，大都是对书中内容的简单堆砌，及简单的加以说明，这让我这个JavaScript小白在理解书中的概念时总是一头雾水，可能是初学的原因，我看到书中很多概念的时候，就像学了一个数学定理，也知道这个定理的意思，但是却不知道这个数学定理怎么使用，也无从知道书中表达的意思，故在数学学习的过程中我经常渴望知道别人的理解。因此，我决定自己写一篇《你不知道的JavaScript》知识梳理，认真揣摩作者的意思，以便更通俗的理解书中概念，尽量领会书中的每一章要表达什么。这本书看的较为仓促。若有错误，望评论区指正，我会仔细查阅资料并给予修改。<br/><br/>再过不久，我便会看剩下的两本书，我也会在博客里写出我的理解，希望看客们可以关注我，并可以给我一些指正。<br/><br/>第一部分&nbsp; 作用域和闭包<br/>第1章&nbsp; 作用域是什么<br/>我觉得本章的难点：<br/><br/>先来回答本章的标题：<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作用域是什么？<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作用域就是变量和函数的可访问范围，控制着变量和函数的可见性与生命周期。使用数学中的函数理解，说白了作用域就是取值范围。<br/><br/>        function　 foo(a) {<br/>            console.log(a); //2<br/>        };<br/>        foo(2);<br/><br/>上述代码是引擎和作用域的对话。这里注意，&nbsp;LHS和RHS是对于赋值操作( foo()函数的执行也可以理解为赋值操作，相当于是将一个函数赋值给foo，然后执行foo)，即赋值操作左边是否有我们要存放的容器，赋值操作右边是否有我们操作的值<br/><br/>即LHS查询：<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行foo()时，对foo的查询（是一个函数）<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;执行foo(2)时，对foo内的a进行查询（a是参数）<br/><br/>RHS查询：<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 执行foo(2)时，对a的赋值操作<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 执行console.log()时，对log()方法的引用<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 执行console.log(a)时，对a赋值的操作<br/><br/>由上述我们可以理解：为什么RHS查询会出现两种错误ReferenceError和TypeError了<br/><br/>前者是因为找不到赋值操作，后者是因为找到了，但是进行了不合理的操作，例如这样<br/><br/>   let foo = null;<br/>        foo(2);<br/>&nbsp;因此，我觉得TypeError错误可以理解为RHS查询成功了，但是进行了非法操作。当然这些书中提到了，我这里是梳理了一边逻辑。<br/><br/>这是小测验的代码，看完书里的解释，又理解了上面的内容，这个小测验就是小菜一碟<br/><br/>        function foo (a){<br/>            var b = a;<br/>            return a + b;<br/>        };<br/>        var c = foo( 2 );<br/>LHS查询：即赋值操作左边的容器。RHS查询：即赋值操作右边的值。<br/><br/>LHS：c=，a=2（foo(2)的隐式操作，就是找有没有a这个参数，因为即便函数有形参也可以不写实参），b=<br/><br/>其实我困惑在为什么a=2的赋值操作右边的=2不定义为RHS查询；我这里猜一下，是因为=2不用查，因为2本身就是值，查询的实质是找，变量是存储数据的容器，因此才需要找。<br/><br/>RHS：foo这个函数，=a，return a+b的a和b(return相当于是一个赋值操作a+b是赋值操作的值)，<br/><br/>本章重要知识：<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 1.JavaScript是编译语言，其编译发生在代码执行前的几微妙。即编译和执行几乎同步。因此JavaScript会用尽各种办法进行性能性能优化。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 2.引擎、编译器、作用域。简单了解作用即可。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 3.LHS和RHS查询<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 4.作用域嵌套：即在嵌套的作用域中，引擎的LHS查询会实行冒泡规则查找<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 5.不成功的LHS查找会自动创建一个全局变量（非严格模式），严格模式下会抛出ReferenceError异常，不成功的RHS查询会抛出ReferenceError异常<br/><br/>第2章&nbsp;词法作用域<br/>我认为本章的难点：<br/><br/>先通俗回答本章的标题：<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 词法作用域：即是语言给代码的书写提供了一套书写规则，按照这个规则而形成的作用域就是词法作用域，说白了就是代码块的作用范围。例如书写函数时，函数内部的数据，外部一般无法访问，这个函数作用范围就是词法作用域的一部分。<br/><br/><br/><br/>&nbsp;在这张图中，这三个作用域气泡就是词法作用域，即是按照代码的书写规则来，形成的代码块的作用范围。<br/><br/>作用域气泡严格包含，即只会出现气泡包含，不会出现气泡交叉<br/><br/>解释一下书中附录A中提到的动态作用域<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 1.JavaScript只有词法作用域！（但this机制和动态作用域很像）<br/><br/>        function foo() {<br/>            console.log(this.a); //2<br/>            console.log(a); //2<br/>        }<br/>        function bar() {<br/>            var a = 3;<br/>            foo();<br/>        }<br/>        var a = 2;<br/>        bar();<br/>&nbsp;这里如果JavaScript是动态作用域，那么输出的将会是3，因为动态作用域会查找调用栈。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 2.词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定的。<br/><br/>关于eval欺骗词法详解<br/><br/>        //eval欺骗词法<br/>        function foo(str, a) {<br/>            eval(str); //欺骗<br/>            console.log(a, b);<br/>        }<br/>        var b = 2;<br/>        foo(\'var b = 3;\', 1)<br/>&nbsp;基本上没啥好说的，就是会直接把传入的字符串转换为js代码，即此时的eval(str)完全等价于var b = 3;<br/><br/>说一下这个函数的妙用，eval会执行字符串，当我们的到的数据是可以执行的字符串时，那么使用eval还是挺炫的。<br/><br/>关于with欺骗词法的详解<br/><br/>先说理解，with会关联一个对象，并且with内的变量均会映射到关联对象的同名属性。with内的变量若没有映射到同名属性，则会LHS查询向上冒泡<br/><br/>        function foo(obj) {<br/>            with(obj) { //会创建作用域气泡<br/>                var b = 3; //实际上会被定义在foo函数内<br/>                // let c = 6;//会被限制在with内<br/>                a = 2; //这个a会直接找obj的属性a<br/>                console.log(a); //2<br/>                console.log(obj.a); //undefined<br/>                console.log(b); //3<br/>                console.log(obj.b); //undefined<br/>            };<br/>            // console.log(a) //ReferenceError<br/>            console.log(b); //3<br/>            // console.log(c);<br/>        };<br/>        var o1 = {<br/>            a: 3<br/>        }<br/>        var o2 = {<br/>            b: 3<br/>        };<br/>        foo(o1);<br/>        console.log(o1.a); //2<br/>        // // console.log(a); //RHS查询，ReferenceError<br/><br/>        // foo(o2);<br/>        // console.log(o2.a); //undefined<br/>        // console.log(o2.b); //undefined<br/>        // console.log(a); //2,window.a<br/>&nbsp;1.这句话的前半句就是说with会创建一个作用域气泡；后半句就是说传入对象的属性会关联到with作用域气泡内的同名标识符。就如，在第6行代码中a可以直接输出为2；而此时，在代码11行和代码23行，输出a的值就是ReferenceError。<br/><br/>就是说with内的赋值操作的规则是：赋值操作优先赋值到传入with内对象的对应属性，当没有对应的属性时，赋值操作会冒泡LHS查询对应的变量容器。<br/><br/>因此，当我们在with内书写c=2时，若传入的对象没有c属性，with会冒泡查询；若有c属性时，with会停止查找，赋值到此属性。<br/><br/>2.这段话：就是在代码3行，使用var声明变量b后，在with的作用域气泡外，即foo函数的气泡内可以访问变量b，即是此处var声明的变量属于with所在的作用域气泡。<br/><br/><br/><br/>当你理解到这里。with的欺骗词法在于，它会给传入对象创建一个作用域气泡，即词法作用域。<br/><br/>就是说，在这个气泡内a=2是不可以在外部访问的，而若此对象没有这个属性，a=2可以修改外部作用域气泡的变量。<br/><br/>说一下with的妙用，把eval嵌入到with内并给eval传入修改关联with对象属性的代码，就可以动态修改对象的数据了。但不要这样做，会导致性能极度下降。<br/><br/>希望读者自行将上述代码放行注释运行查看，有些细节，需要运行代码自我体会。<br/><br/>本章重要知识：<br/><br/>1.词法作用域就是定义在词法阶段的作用域，即作用域是由书写代码时函数声明的位置决定。<br/><br/>2.作用域会在找到第一个匹配的标识符时停止，因此会有“遮蔽效应。<br/><br/>3.欺骗词法：eval和with（会创建作用域气泡）<br/><br/>4.JavaScript引擎会在编译阶段进行数项的性能优化<br/><br/>5.欺骗词法会使得JavaScript引擎无法在编译时对作用域查找进行优化。<br/><br/>6.作用域查找始终从运行时所处的最内部作用域开始。<br/><br/>第3章 函数作用域和块作用域<br/>我认为本章的难点：<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.立执行函数的小例子<br/><br/>        undefined = true; //企图覆盖undeined<br/>        console.log(undefined); //undefined,可见修改不成功<br/>        (function IIFE(undefined) {<br/>            console.log(undefined) //undefined,<br/>            var a;<br/>            if (a === undefined) {<br/>                console.log(\'Undefined  is  safe  here!\')<br/>            }<br/>        })(); //没有传入参数<br/>这个例子，即是想覆盖默认值，但是实际发现，undefined并不会被覆盖<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.IIFE函数可以倒置代码的执行顺序<br/><br/>        var a = 2;<br/>        (function IIFE(def) {<br/>            def(window);<br/>        })(function def(global) {<br/>            var a = 3; //会有遮蔽效应<br/>            console.log(a); //3<br/>            console.log(global.a); //2<br/>        });<br/>这段代码其实很好理解，即def被当作参数传递给了IIFE，并在IIFE内部执行，两次输出的不同实质是遮蔽效应导致<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/><br/>本章重要知识：<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 1.无论标识符声明出现在作用域的何处买这个标识符所代表的标量或函数都将依附于所处作用域的气泡。（这里说的原理，应该就是变量提升和函数优先）<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 2.每一个函数内部都是一个作用域气泡，基于此，我们可以将代码包裹在函数作用域气泡内，这种基于作用域的隐藏方法即为最小特权原则。<br/><br/>        function foo() {<br/>            function bar(a) {<br/>                i = 3; //修改for循环中所属作用域中的i<br/>                for (var i = 0; i &lt; 10; i++) {<br/>                    bar(i * 2); //此时造成无限循环了<br/>                }<br/>            }<br/>        }<br/>&nbsp;这里就是出现了变量冲突，我们应该让bar函数内部的i成为本地变量。<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.很多库为了避免变量冲突，大都是定义一个独特的对象，让每个变量、方法成为变量的属性。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 4.具名函数和匿名函数表达式<br/><br/>        //注意，因为是表达式，所以结尾需要使用分号<br/>        //匿名函数表达式<br/>        (function() {<br/>            var a = 3;<br/>            console.log(a);<br/>        });<br/>        //具名函数表达式<br/>        (function foo() {<br/>            var a = 3;<br/>            console.log(a);<br/>        });<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.立执行函数表达式&nbsp;<br/><br/>        //形式一<br/>        (function foo(a) {<br/>            console.log(a);<br/>        }(3));<br/>        //形式二<br/>        (function foo(a) {<br/>            console.log(a);<br/>        })(3);<br/>&nbsp; &nbsp; &nbsp; &nbsp; 6.JavaScript语言表面上没有块级作用域的相关功能，实际上with（仅关联对象的属性同名标识符具有块级，语言表述能力有限，请自行到上述with解释查看。书中把这种表现形式称为块级，我觉得不够严谨，因为在with内声明的非同名属性标识符实际上是定义在with所在作用域气泡内的）、try/catch的catch均会创建一个块级作用域。try/catch的性能不佳<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 7.let关键字可以将变量绑定到所在的任意作用域中，即let可以为其声明的变量隐式地劫持了所在的块作用域。<br/><br/>第4章&nbsp; 提升<br/>我认为本章的难点：<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.块内作用域的函数提升机制。JavaScript未来可能会改变这种机制，因此尽量不要在块内声明函数。<br/><br/>        // foo(); //TypeError: foo is not a function<br/>        var a = true;<br/>        console.log(foo); //undefined<br/>        if (a) { //实际上被提升到if块内了<br/>            function foo() {<br/>                console.log(\'a\');<br/>            }<br/>        } else {<br/>            function foo() {<br/>                console.log(\'b\');<br/>            }<br/>        }<br/>        console.log(foo);<br/>本章重要知识点：<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.JavaScript编译器编译前会优先找到所有声明，并用合适的作用域将其关联起来。因此，包括变量和函数在内的所有声明都会在任何代码被执行前优先被处理。<br/><br/>        //写的是这<br/>        foo();<br/><br/>        function foo() {<br/>            console.log(a); //undefined<br/>            var a = 2;<br/>        }<br/>        //实际运行的是这<br/>        function foo() {<br/>            var a;<br/>            console.log(a);<br/>            a = 2;<br/>        }<br/>        foo();<br/>&nbsp; &nbsp; &nbsp; &nbsp; 2.函数声明和变量声明均会被提升，即函数名和变量名同名时，函数提升会导致忽略同名的变量。就是函数提升的优先级较高。<br/><br/>第5章&nbsp; 作用域闭包<br/>&nbsp; &nbsp; &nbsp; &nbsp; 此时我真正理解了什么是闭包，才体会到了 启示 ——&nbsp;JavaScript中的闭包无处不在！！！ 这句话的含义。<br/><br/>我认为本章的难点：<br/><br/>        function foo() {<br/>            var a = 2;<br/><br/>            function bar() {<br/>                console.log(a)<br/>            }<br/>            return bar;<br/>        }<br/>        foo()(); //2<br/>        var baz = foo(); //2<br/>        baz();<br/>闭包就是JavaScript引擎阻止了正在被引用函数的垃圾回收，即代码中bar持续被引用，也即是foo的作用域气泡持续被引用。<br/><br/>就行例子中，foo函数已经被执行了，foo函数理应会被回收，但是JavaScript引擎阻止了回收。<br/><br/>我们通俗的理解闭包，即为函数被封闭在作用域气泡内，函数的调用却在作用域气泡之外。<br/><br/>上述，是我试图用书中解释理解闭包，但总觉得过于学术，因此，我的理解：<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 0.我把函数的执行，理解为函数名是函数执行的开关，函数名()就会打开这个开关，“触发”函数。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 1.函数的执行、变量的取值均是一种“触发”；即函数名(),直接引用变量名，这些均是对函数及变量的“触发”。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 2.但是函数和变量不同，函数的执行是函数名()，函数名即为变量(我称变量为容器)，仅是存储函数的容器（实际上存放的是函数的指针，即函数的快捷方式），请看下述代码<br/><br/>        (function() {<br/>            function foo() {<br/>                var a = 2;<br/><br/>                function bar() {<br/>                    console.log(a)<br/>                }<br/>                return bar;<br/>            }<br/>            console.log(foo); //函数foo<br/>            console.log(window.foo); //undefined<br/><br/>            foo = 12;<br/>            console.log(foo) //12<br/>            console.log(window.foo); //undefined<br/>        })();<br/>&nbsp;说明foo可以被赋值，且不是window对象的属性，故可以断定foo就是一个变量(容器)，当然，其实学过C语言或者其他语言的都是知道这一点的，我仅是为了更加确定而已。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 3.因此，我说函数的“触发“需要两个条件：函数名和()。()会自动找到变量内的函数并执行<br/><br/>        //闭包的深度解析<br/>        function foo() {<br/>            var a = 2;<br/><br/>            function bar() {<br/>                console.log(a)<br/>            }<br/>            return bar;<br/>        }<br/>        foo()(); //2<br/>        var baz = foo(); //2<br/>        baz();<br/>&nbsp;在这段代码中，bar仅仅是一个存放函数的变量，执行函数foo后会返回bar变量。<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.现在拉回来，由于JavaScript是词法作用域，函数的执行，其执行的作用域是在函数定义的作用域气泡内。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 5.即函数foo是把bar函数的“触发”开关返回到了外面。外面使用()执行了foo内函数bar，接着就是正常词法作用域的操作了。<br/><br/>        function setupBot(name, selector) {<br/>            $(selector).click(function activator() {<br/>                console.log(\'Activating\' + name);<br/>            })<br/>        }<br/>        setupBot(\'Closure Bot 1\', \'#bot_1\')<br/>理解到这里，上面这段代码之所以是闭包，原因即是，内部回调函数的执行是由外部的setupBot控制的。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 6.解释下循环和闭包<br/><br/>        for (var i = 1; i &lt;= 5; i++) {<br/>            // var j = i;<br/>            setTimeout(function timer() {<br/>                console.log(j)<br/>            }, i * 1000);<br/>        }<br/>这里仅有两级作用域，全局作用域(for循环内)和回调函数内的作用作用域，根据词法作用域规则，回调函数作用域会共享全局作用域，故最终都会输出6<br/><br/>        for (var i = 1; i &lt;= 5; i++) {<br/>            (() =&gt; {<br/>                var j = i;<br/>                setTimeout(function timer() {<br/>                    console.log(j)<br/>                }, i * 1000);<br/>            })();<br/><br/>        }<br/>这里使用了立执行函数(ES6语法)，因此，此时有三级作用域，即全局作用域(for内)、立执行函数的作用域、回调函数的作用域。详细解释下：每次迭代会有5个立执行函数作用域同级和5个回调函数作用域同级，且分别是包含关系<br/><br/>故每次迭代时定义的 j 变量分别属于5个立执行函数的作用域，就是说没有 j 的进行数据存储的话，回调函数会由词法作用域规则向上冒泡查找i，这样还是输出5个6<br/><br/>        for (var i = 1; i &lt;= 5; i++) {<br/>            ((j) =&gt; {<br/>                setTimeout(function timer() {<br/>                    console.log(j)<br/>                }, j * 1000);<br/>            })(i);<br/><br/>        }<br/>这个改进之后的代码，事实上说明了，函数的每次执行，参数都会进行一次绑定。和使用let很像<br/><br/>        for (let i = 1; i &lt;= 5; i++) {<br/>            setTimeout(function timer() {<br/>                console.log(i)<br/>            }, i * 1000);<br/>        }<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.模块和闭包连用。模块就是一个封闭函数返回了一个对象(函数本质也是对象)，因此模块内部形成闭包，故可以通过返回的对象对模块内部持续引用，进行操作。<br/><br/>        var foo = (function CoolModule(id) {<br/>            function change() {<br/>                //修改公共API<br/>                publicAPI.identify = identify2;<br/>            };<br/>            function identify1() {<br/>                console.log(id);<br/>            };<br/><br/>            function identify2() {<br/>                console.log(id.toUpperCase());<br/>            };<br/>            var publicAPI = {<br/>                change: change,<br/>                identify: identify1<br/>            };<br/>            return publicAPI; //返回模块<br/>        })(\'foo module\');<br/>        //此时foo对其模块内部持续引用<br/>        //故下述方法执行了模块内部的函数<br/>        foo.identify();<br/>        foo.change();<br/>        foo.identify();<br/>&nbsp; 理解了闭包之后，理解模块变得轻而易举。上述代码没啥说的，就是模块产生了闭包，然后对模块内部的持续引用，进行的一些操作。<br/><br/>8.书中 现代模块机制 的一个代码案例<br/><br/>        //现代的模块机制<br/>        var MyModules = (function Manager() {<br/>            var modules = {};<br/><br/>            function define(name, deps, impl) {<br/>                for (var i = 0; i &lt; deps.length; i++) {<br/>                    deps[i] = modules[deps[i]];<br/>                };<br/>                modules[name] = impl.apply(impl, deps);<br/>            };<br/><br/>            function get(name) {<br/>                return modules[name];<br/>            };<br/>            return {<br/>                define: define,<br/>                get: get,<br/>            }<br/>        })();<br/>        MyModules.define(\'bar\', [], function() {<br/>            function heool(who) {<br/>                return \'Let me introduce: \' + who;<br/>            };<br/>            return { //返回的是对象<br/>                heool: heool<br/>            };<br/>        });<br/>        MyModules.define(\'foo\', [\'bar\'], function() {<br/>            var hungry = \'hippo\';<br/><br/>            function awesome() {<br/>                console.log(bar.hello(hungry).toUpperCase());<br/>            };<br/>            return { //返回的是对象<br/>                awesome: awesome<br/>            };<br/>        });<br/>        var bar = MyModules.get(\'bar\');<br/>        var foo = MyModules.get(\'foo\');<br/>        console.log(bar.hello(\'hippo\')); //Let me introduce:hippo<br/>        foo.awesome();<br/>&nbsp;其实挺好理解的，就是有点绕：<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 先说defined函数:一个参数name是会给modules添加一个属性，第二个参数deps就是对modules的属性遍历，并且将遍历的东西传入到第三个参数impl(回调函数)，第三个参数也会变成modules的属性。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 再说get函数：就是简单的获取moduls的属性<br/><br/>这里说一下代码中第一次执行MoModules.define()时传入了一个空数组，显然modules获取不到属性，则下面的impl.apply()传入的deps就是空了；也就是说apply的第二个参数是一个空，apply的第二个参数是传递给原函数的，即是第一次执行的时候，回调函数内没有传值。第二次同理。<br/><br/>当然，还是需要自己认真体会代码的。<br/><br/>9.关于附录C&nbsp; this词法的一些理解<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 在setTimeout中this指向了window，官网给出的答案是：由setTimeout()调用的代码运行在与所在函数完全分离的执行环境上<br/><br/>在我看来，obj.cool是指向了cool函数，js引擎在执行obj.cool()时，是一种obj修饰的调用；由此foo也指向了cool函数，故此时foo是对cool函数的直接引用，foo()执行时是不加修饰的调用；<br/><br/>因此，我认为setTimeout的参数就是相当于foo一样，是对cool函数的不加修饰的调用。<br/><br/>        //附录C  this词法<br/>        var obj = {<br/>            id: \'awesome\',<br/>            cool: function coolFn() {<br/>                console.log(this.id);<br/>                // console.log(this);<br/>            }<br/>        };<br/>        var id = \'not awesome\';<br/>        obj.cool(); //awesome<br/>        //this的绑定取决于调用位置，故这里是对coolFn函数的直接引用，即直接调用<br/>        var foo = obj.cool;<br/>        foo(); //not awesome<br/><br/>        // 可见这里也是直接引用<br/>        setTimeout(obj.cool, 100); //not awesome<br/>        // console.log(window.id)<br/>本章知识点：<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 1.基本都是难点，要记得不多，但均需要理解。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 2.模块模式的必要条件：<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ①必须由外部的粉笔函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ②封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 3.模块文件中的内容会被当做包含在作用域闭包中一样处理。类似于函数闭包模块.<br/><br/>第二部分&nbsp; this和对象模型<br/>第1章&nbsp; 关于this<br/>本章就是讲了一些对this的误区<br/><br/>我认为的本章难点：<br/><br/>无<br/><br/>书中本章知识点：<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 1.为什么要使用this？this提供了一种更简洁且易于复用的API设计，我们可以通过更改this指向，隐式的“传递”一个对象的引用。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 2.this不指向自身。<br/><br/>        // 关于this<br/>        function foo(num) {<br/>            console.log(\'foo: \' + num);<br/>            //记录foo被调用的次数<br/>            this.count++;<br/>        };<br/>        foo.count = 0;<br/>        var i = null;<br/>        for (i = 0; i &lt; 10; i++) {<br/>            if (i &gt; 5) {<br/>                foo(i);<br/>            }<br/>        }<br/>        console.log(foo.count); //0<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.this在任何情况下都不指向函数的词法作用域，作用域存在于JavaScript引擎内部。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 4.经典的this错误，它试图跨越边界<br/><br/>        var obj = {}<br/><br/>        function foo() {<br/>            var a = 2;<br/>            this.bar();<br/>        }<br/><br/>        function bar() {<br/>            // LHS查询对象的时候貌似会自动创建属性，应该时新改的。<br/>            console.log(this.a); //undefined<br/>            console.log(obj.a); //undefined<br/>        }<br/>        // this.foo(); //undefined<br/>        //我觉得定义在全局作用域的函数也会成为全局对象的属性<br/><br/>        foo();<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.this的绑定和函数的声明位置没有任何关系，只取决于函数的调用方式&nbsp;.即this实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。<br/><br/>第2章&nbsp; this全面解析<br/>本章就是说了this的指向的规则，及怎么修改this指向，<br/><br/>我认为的本章难点：<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 1.书中的MDN的bind实现，最后的部分没看懂<br/><br/>      if (!Function.prototype.bind) { //检擦Function的原型是否有bind方法<br/>            Function.prototype.bind = function(OThis) { //定义bind方法<br/>                if (typeof this !== \'function\') { //检查调用者是否是函数<br/>                    //与 ECMAScript 5最接近的<br/>                    //内部 IsCallacle 函数<br/>                    throw new TypeError( //如果不是函数，则抛出一个错误，这个函数会停止后续代码的执行<br/>                        \'Function.prototype.bind - what is trying\' +<br/>                        \'to be bound is not callable\'<br/>                    );<br/>                };<br/>                //分割bind函数的参数，slice可以分割arguments这个伪数组，1代表从第2个索引开始分割arguments<br/>                var aArgs = Array.prototype.slice.call(arguments, 1),<br/>                    fToBind = this, //bind调用者<br/>                    fNOP = function() {}, //<br/>                    fBound = function() {<br/>                        return fTobind.apply(<br/>                            (<br/>                                this instanceof fNOP //fNOP的原型链是否在this原型链上<br/>                                &amp;&amp;<br/>                                OThis ? this : OThis //oThis是否存在<br/>                            ),<br/>                            aArgs.concat(<br/>                                Array.prototype.slice.call(arguments)<br/>                            )<br/>                        );<br/>                    };<br/>                fNOP.prototype = this.prototype;<br/>                fBound.prototype = new fNOP();<br/>                return fBound;<br/>            }<br/>        }<br/>&nbsp; &nbsp; &nbsp; &nbsp; 2.书中软绑定源码，我现在还没能完全理解<br/><br/>        //软绑定<br/>        if (!Function.prototype.softBind) {<br/>            Function.prototype.softBind = function(obj) {<br/>                var fn = this;<br/>                //捕获所欲curried参数<br/>                var curried = [].slice.call(arguments, 1);<br/>                var bound = function() {<br/>                    return fn.apply(<br/>                        (!this || this === (window || global)) ?<br/>                        obj : this,<br/>                        curried.concat.apply(curried, arguments)<br/>                    );<br/>                };<br/>                bound.prototype = Object.create(fn.prototype);<br/>                return bound;<br/>            }<br/>        }<br/><br/>        function foo() {<br/>            console.log(\'name: \' + this.name);<br/>        }<br/>        var obj = {<br/>                name: \'obj\'<br/>            },<br/>            obj2 = {<br/>                name: \'obj2\'<br/>            },<br/>            obj3 = {<br/>                name: \'obj3\'<br/>            };<br/>        var fooOBJ = foo.softBind(obj); //绑定到了obj上<br/>        fooOBJ(); //name:obj<br/>        obj2.foo = foo.softBind(obj);//绑定到obj上<br/>        obj2.foo(); //name:obj2，貌似和隐式绑定差不多<br/>        fooOBJ.call(obj3); //name:obj3<br/>        setTimeout(obj2.foo, 100); //name:obj<br/>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3.箭头函数会捕获调用上级函数的this，且无法修改。箭头函数可以像bind一样确保函数的this被绑定到指定对象，实质是使用词法作用域取代了this机制，内部有类似于var self = this;这句代码&nbsp; &nbsp;<br/><br/>        //箭头函数<br/>        function foo() {<br/>            //返回一个箭头函数<br/>            return (a) =&gt; {<br/>                //this继承自foo()<br/>                console.log(this.a)<br/>            }<br/>        }<br/>        var obj1 = {<br/>            a: 2<br/>        };<br/>        var obj2 = {<br/>            a: 3<br/>        };<br/>        var bar = foo.call(obj1);<br/>        bar.call(obj2); //2<br/>本章重要知识点：<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 1.调用位置就是函数在代码中被调用的位置（而不是声明位置）。需要分析调用栈。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 2.函数运行在“非严格模式”下，函数会执行默认绑定；但在严格模式下调用函数，则不影响函数的默认绑定 。区分一下运行和调用。默认绑定就是全局函数默认绑定到全局对象上。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 3.当函数引用有上下文对象时，隐式绑定规则会把函数调用中的this绑定到这个上下文对象。对象的属性引用链中只有上一层或者说最后一层在调用位置中起作用<br/><br/>        function foo() {<br/>            console.log(this.a)<br/>        }<br/>        var obj2 = {<br/>            a: 42,<br/>            foo: foo<br/>        }<br/>        var obj1 = {<br/>            a: 2,<br/>            obj2: obj2<br/>        }<br/>        obj1.obj2.foo(); //42<br/>&nbsp; &nbsp; &nbsp; &nbsp; 3.&nbsp;隐式绑定造成this丢失的实质是对一个函数的直接引用（不带任何修饰的函数调用）<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 4.回调函数的函数可能会修改this，流行的JavaScript库中事件处理器常会把回调函数的this强制绑定到触发事件的DOM元素上。我是用jQuery发现并没有像后半句所说的那样<br/><br/>        window.addEventListener(\'load\', function() {<br/>            console.log(this); //window<br/>            document.querySelector(\'p\').addEventListener(\'click\', function(e) {<br/>                function foo() {<br/>                    console.log(this); //window<br/><br/>                }<br/>                foo();<br/>                //这里就是绑定到触发的DOM元素上<br/>                console.log(this); //p<br/>                console.log(e.target); //p<br/>            })<br/>        })<br/>        $(function() {<br/>            console.log(this); //#document,貌似是jQuery的文档对象<br/>            $(\'p\').on(\'click\', function(e) {<br/>                function foo() {<br/>                    console.log(this); //window<br/>                }<br/>                foo();<br/>                console.log(this); //p<br/>                console.log(e.target); //p<br/>            })<br/>        })<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.硬绑定call和apply2。硬绑定就是使用新函数对call和apply语句进行了隔离。<br/><br/>        //硬绑定，<br/>        function foo() {<br/>            console.log(this.a)<br/>        }<br/>        var obj = {<br/>            a: 2,<br/>            foo: foo<br/>        };<br/>        var a = 3;<br/>        var bar = function() {<br/>            // foo();<br/>            return foo.call(obj); //2<br/>        };<br/>        bar();<br/>        setTimeout(bar, 100); //2<br/>        //硬绑定的bar不可能再修改它的this。<br/>        //上面这句和废话一样，bar现在是一个新函数，这些操作均是对新函数的操作，怎么会修改foo的this<br/>        bar.call(window); //2<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.new操作符调用的是普通函数，即所有函数均可使用new调用。不存在所谓的”构造函数“，只有对于函数的”构造调用“，new的操作：<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.创建（或者说构造）一个全新的对象<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.这个新对象会被执行[[Prototype]]连接<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3.这个新对象会被绑定到函数调用的this<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4.如果函数没有返回其他对象，那么new表达式的函数调用会自动返回这个新对象&nbsp;<br/><br/>        function foo(a) {<br/>            this.a = a;<br/>        }<br/>        var bar = new foo(2);<br/>        //返回了一个新对象，因此可以bar.a访问新对象的属性<br/>        console.log(bar.a); //2<br/>&nbsp; &nbsp; &nbsp; 7.判断this：<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ①函数是否在new中调用(new 绑定)？如果是的话this绑定的是新创建的对象。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var&nbsp; bar = new foo();<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ②函数是否通过call、apply（显示绑定）或着硬绑定调用?如果是的话，this绑定的是指定的对象。<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp; bar&nbsp;= foo.call(obj2)<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ③函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this绑定的是那个上下文对象。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var bar =obj1.foo();<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ④如果均不是的话，使用默认绑定。如果严格模式下，就绑定到undefined，否则绑定到全局对象。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var&nbsp; bar&nbsp; =&nbsp; foo();<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 8.柯里化：把除了第一个参数（第一个参数用于绑定this）之外的其他参数都传给下层的函数（这种技术称为”部分应用“，是“柯里化”的一种）<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 9.JavaScript中创建一个空对象最简单的方法都是object.create(null)。这么做不会创建object.prototype这个委托，比{}“更空”。<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.对于默认绑定来说，决定this绑定对象的并不是调用位置是否处于严格模式，而是函数体是否处于严格模式。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 11.硬绑定会大大降低函数的灵活性，使用硬绑定之后就无法使用隐式绑定或者显示绑定来修改this。<br/><br/>第3章&nbsp; 对象<br/>有一种常见的说法“JavaScript中万物皆是对象”，这显然是错误的。<br/><br/>本章就是讲了对象的一些操作：创建、配置、封印<br/><br/>本章难点：<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.Symbol.iterator：为每一个对象定义了默认的迭代器。该迭代器可以被 for-of&nbsp;循环使用。for-of会找内置的@@iterator对象并调用next()方法来遍历数据<br/><br/>        //自定义对象迭代器<br/>        var myObject = {<br/>            a: 2,<br/>            b: 3<br/>        };<br/>        Object.defineProperty(myObject, Symbol.iterator, {<br/>                enumerable: false,<br/>                writable: false,<br/>                configurable: true,<br/>                value: function() {<br/>                    var o = this;<br/>                    var idx = 0;<br/>                    var ks = Object.keys(o);<br/>                    return {<br/>                        next: function() {<br/>                            return {<br/>                                value: o[ks[idx++]],<br/>                                done: (idx &gt; ks.length)<br/>                            };<br/>                        }<br/>                    };<br/>                }<br/>            })<br/>            //手动遍历myObject<br/>        var it = myObject[Symbol.iterator]();<br/>        console.log(it.next()); //{value:2,done:false}<br/>        console.log(it.next()); //{value:3,done:false}<br/>        console.log(it.next()); //{value:undefined,done:true}<br/>        //for-of遍历<br/>        for (var v of myObject) {<br/>            console.log(v)<br/>        }; //2,3<br/>&nbsp;代码的意思就是定义了一个Symbol.iterator属性，这个属性的value是个函数，函数内部有各种操作。文字表达起来有点费劲，可以尝试运行代码自行体会<br/><br/>本章知识点：<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.JavaScript的六种主要类型：string，number，boolean，null，undefined，object。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typeof&nbsp; null;之所以返回Object，是因为JavaScript中二进制前三位均为0，就会被判定为object类型，而null的二进制表示全为0，自然被判定为object了<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 2.内置对象：String，Number，Boolean，Object，Function，Array，Date，RegExp，Error。<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.JavaScript会自动将字符串，数字等使用方法时，会转换为内置对象，如‘I am string’，实际上会进行new String(‘I am string’)<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 4.在对象中，属性名永远是字符串，如果你使用string（字面量，字符串的存储是固定的）以外的其他值作为属性名，那它首先会被转换为一个字符串；<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 5.数组也是对象，因此可以给数组添加属性，但是如果试图给数组添加一个类数字属性，进行键访问的时候，此属性会变成一个数值下标<br/><br/>        var myArray = [\'foo\', \'turnip\', 43];<br/>        myArray[\'3\'] = \'kkk\';<br/>        myArray.length; //4<br/>        myArray[3]; //43<br/>&nbsp; &nbsp; &nbsp; &nbsp; 6.Object.defineProperty官方描述：Object.defineProperty。该方法可以配置对象<br/><br/>        \'use strict\' //修改只读属性，会报错<br/>        var myObject = {};<br/>        Object.defineProperty(myObject, \'a\', {<br/>            value: 2,<br/>            writeable: false, //不可写,只读<br/>            configurable: true, //可配置的<br/>            enumerable: true //可枚举<br/>        });<br/>        myObject.a = 3;<br/>        console.log(myObject.a); //2<br/>&nbsp; &nbsp; &nbsp; &nbsp; 7.结合 writeable:false和configurable:false 就可以创建一个真正的常量属性(不可修改、重定义或删除)<br/><br/>        var myObject = {};<br/>        Object.defineProperty(myObject, \'FAVORITE_NUMBER\', {<br/>            value: 42,<br/>            writable: false,<br/>            configurable: false<br/>        })<br/>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;8.Object.preventExtensions官方解释：Object.preventExtensions。该方法可以让一个对象变的不可扩展，也就是永远不能再添加新的属性。<br/><br/>        var myObject = {<br/>            a: 2<br/>        };<br/>        Object.preventExtensions(myObject);<br/>        myObject.b = 3;<br/>        console.log(myObject.b); //undefined<br/>&nbsp; &nbsp; &nbsp; &nbsp; 9.Object.seal()官方解释：Object.seal。该方法封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置、不可删除。当前属性的值只要原来是可写的就可以改变。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 10.Object.freeze()官方解释：Object.freeze()。这个方法是可以应用在对象上的级别对高的不可变性。<br/><br/>&nbsp; &nbsp;11.getter和setter均是一个隐藏函数，前者获取属性时调用，后者设置属性时调用。<br/><br/>        var myObject = {<br/>            //给a定义一个getter<br/>            get a() {<br/>                return this._a_;<br/>            },<br/>            set a(val) {<br/>                this._a_ = val * 2;<br/>            }<br/>        }<br/>        myObject.a = 2;<br/>        console.log(myObject.a);//4<br/>        console.log(myObject._a_); //4，创建了一个属性<br/>&nbsp; &nbsp; &nbsp; &nbsp; 11可枚举 就相当于 可以出现在对象属性的遍历中。for-in会静默，但是for循环可以。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; propertyIsEnumerable()会检查给定的属性名是否直接存在于对象中（而不是原型链上）并且满足enumerable：true<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; Object.keys()会返回一个数组，包含所有可枚举的属性，Object,getOwnpropertyNames()会返回一个数组，包含所有属性，无论他们是否可枚举；<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object.prototype.hasOwnProperty和in的区别在于是否查找[[Prototype]]链<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; object.keys()和Object.getOwnPropertyNames()都只会查找对象直接包含的属性<br/><br/>        var myObject = {};<br/>        Object.defineProperty(myObject, \'a\',<br/>            //让a像普通属性一样可以枚举<br/>            {<br/>                enumerable: true,<br/>                value: 2<br/>            });<br/>        Object.defineProperty(myObject, \'b\',<br/>            //让a像普通属性一样可以枚举<br/>            {<br/>                enumerable: false,<br/>                value: 2<br/>            });<br/>        console.log(myObject.b); //3<br/>        console.log((\'b\' in myObject)); //true<br/>        console.log(myObject.hasOwnProperty(\'b\')); //true<br/>        for (var key in myObject) {<br/>            console.log(key, myObject[key]);<br/>        }; //\'a\' 2<br/>        console.log(myObject.propertyIsEnumerable(\'a\')); //true<br/>        console.log(myObject.propertyIsEnumerable(\'b\')); //false<br/>        console.log(Object.keys(myObject)); //[\'a\']<br/>        console.log(Object.getOwnPropertyNames(myObject)); //[\'a\',\'b\']<br/>第4章&nbsp; 混合对象 “类”<br/>只要理解了this指向和对象，这一章的内容理解起来很容易，都是一些概念而已。<br/><br/>本章难点：<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 1.多态就是任何方法均可以引用继承层次中高层的方法，及继承使得方法可以在多类中映射。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 2.显示多态就是把显示的将父类的方法引入子类，但此时方法显示绑定的对象是子类<br/><br/>本章知识点：<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 1.类/继承描述了一种代码的住址结构——一种在软件中对真实世界中问题领域的建模方法，面向对象编程强调的是数据和操作数据的行为本质上是互相关联的。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 2.JavaScript中并没有类，JavaScript只是提供了一些近似类的语法，因此JavaScript的类是一种设计模式(类本身就是一种设计模式)。如ES6的class<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 3.类实例是由一个特殊的类方法构造的，这个方法名通常和类同名，被称为构造函数。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 4.类的继承其实就是复制<br/><br/><br/>第5章&nbsp; 原型<br/>原型的实质就是对象之间的关联关系。<br/><br/>本章难点：<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 1.原型的本质就是一种关联关系，原型链就是关联树，即JavaScript引擎会查找原型链<br/><br/>        var anotherObject = {<br/>            a: 2<br/>        };<br/>        //创建一个关联到anotherObject的对象<br/>        var myObject = Object.create(anotherObject);<br/>        //注意此时myObject.a并不存在，但是JavaScript引擎会在原型链上查找该属性<br/>        console.log(myObject.a); //2<br/>&nbsp; &nbsp; &nbsp; &nbsp; 2.隐式屏蔽<br/><br/>        var anotherObject = {<br/>            a: 2<br/>        };<br/>        var myObject = Object.create(anotherObject);<br/>        console.log(anotherObject.a); //2<br/>        console.log(myObject.a); //2<br/>        console.log(anotherObject.hasOwnProperty(\'a\')); //true<br/>        console.log(myObject.hasOwnProperty(\'a\')); //false<br/>        console.log(anotherObject);<br/>        console.log(myObject); //属于anotherObject下一级<br/>        myObject.a++; //myObject.a= myObject.a + 1<br/>        console.log(anotherObject.a); //2<br/>        console.log(myObject.a); //3<br/>        console.log(myObject.hasOwnProperty(\'a\')); //true<br/>&nbsp; &nbsp; &nbsp; &nbsp; 3.new的关联，new的操作，就是创建了一个关联到其他对象的新对象。实际上我们并没有复制“类“，只是让他们关联而已<br/><br/>        function Foo() {}<br/>        var a = new Foo();<br/>        //new操作后，都会被关联到Foo.prototype对象上<br/>        console.log(Object.getPrototypeOf(a) === Foo.prototype); //true<br/>本章知识点：<br/><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.使用for-in&nbsp;遍历对象时原理和查找[[Prototype]]链类似，任何可以通过原型链访问到的属性都会被枚举。使用in操作符来检查属性在对象中是否存在时，同样会查找对象的整条原型链。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 2.所有普通的[[Prototype]]链最终都会指向内置的Object.prototype。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 3.函数不是构造函数，但当且仅当使用new时，函数调用会变成”构造函数调用“。<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 4.Object.create()会创建一个新对象，并把它关联到我们指定的对象上<br/><br/>        //兼容的Object.create<br/>        if (!Object.create) {<br/>            Object.create = function(o) {<br/>                function F() {}; //声明空函数<br/>                F.prototype = o;<br/>                return new F();<br/>            }<br/>        }<br/>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5.内部委托。避免明明当前对象没有这个属性，但是却神奇的可以调用。也使得API设计更加清晰<br/><br/>        var anotherObject = {<br/>            cool: function() {<br/>                console.log(\'cool!\');<br/>            }<br/>        }<br/>        var myObject = Object.create(anotherObject);<br/>        myObject.doCool = function() {<br/>            this.cool(); //内部委托<br/>        }<br/>        myObject.doCool();<br/>第6章&nbsp; 行为委托<br/>这一章没什么可说的，就是对委托这种设计模式的讲解，理解了this机制、对象、原型之后，书中的代码也并没有什么难点。<br/><br/>知识回顾：<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 1.如果在第一个对象上没有找到需要的属性或者方法引用，JavaScript引擎会继续在[[Prototype]]关联的对象上进行查找。&nbsp;<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 2.JavaScript的原型链机制的本质就是对象与对象之间的关联关系。<br/><br/>本章难点：<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; 1.类理论和委托理论的对比：<br/><br/>        //类理论(伪代码)<br/>        class Task {<br/>            id;<br/>            //函数Task()<br/>            Task(ID) {<br/>                id = ID;<br/>            }<br/>            outputTask() {<br/>                output(id);<br/>            }<br/>        };<br/>        class XYZ inherits Task {<br/>            label;<br/>            //构造函数XYZ<br/>            XYZ(ID, Label) {<br/>                super(ID);<br/>                label = Label;<br/>            }<br/>            outputTask() {<br/>                super();<br/>                output(label);<br/>            }<br/>        };<br/>        class ABC inherits Task {<br/>            //...<br/>        };<br/><br/>        //委托理论<br/>        Task = {<br/>            setID: function(ID) {<br/>                this.id = ID;<br/>            },<br/>            output: function() {<br/>                console.log(this.id)<br/>            }<br/>        };<br/>        // 让XYZ委托给Task<br/>        XYZ = Object.create(Task);<br/>        XYZ.prepareTask = function(ID,Label){<br/>            this.setID(ID);<br/>            this.label = Label;<br/>        }<br/>        XYZ.outputTaskDetails = function(){<br/>            this.outputID();<br/>            console.log(this.label);<br/>        };<br/>        //ABC = Object.create(Task);<br/>        //ABC ... = ...<br/>可以看出，类理论：当实例化子类时，子类的实例会复制父类和子类的行为&nbsp;。&nbsp;可参考java类原理<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 委托理论：”子类“(对象)通过[[Prototype]]委托给了”父类“，当调用子类中没有的方法时，会通过委托关系查找关联的对象，又由于调用位置触发this的隐式绑定规则，故this的绑定仍是”子类“，而这正是我们想要的结果。由此看来委托的设计模式更加简洁。&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br/><br/>本章知识点：<br/><br/>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 无<br/><br/><br/></p>','你不知道的JavaScript 上卷 知识梳完结语：2021年7月2日，终于写完了。我原本是想用一周的时间看完这本上卷的，也是没想到前前后后竟然花了十多天的时间。还好，收获还是挺多的，书中的内容的确让我对JavaScript这门语言有了更深的认识。这个知识梳理适合那些已经看完了《你不知道的JavaScript&nbsp;上卷》，但仍觉得一头雾水的人，我也看了很多博主写了这本书的知识梳理，大都是对书中内容的简单堆砌，及简单的加以说明，这让我这个JavaScript小白在理解书中的概念时总是一头雾水，可能是初学的原因，我看到书中很多概念的时候，就像学了一个数学定理，也知道这个定理的意思，但是却不知道这个数学定理怎么使用，也无从知道书中表达的意思，故在数学学习的过程中我经常渴望知道别人的理解。因此，我决定自己写一篇《你不知道的JavaScript》知识梳理，认真揣摩作者的意思，以便更通俗的理解书中概念，尽量领会书中的每一章要表达什么。这本书看的较为仓促。若有错误，望评论区指正，我会仔细查阅资料并给予修改。再过不久，我便会看剩下的两本书，我也会在博客里写出我的理解，希望看客们可以关注我，并可以给我一些指正。第一部分&nbsp; 作用域和闭包第1章&nbsp; 作用域是什么我觉得本章的难点：先来回答本章的标题：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作用域是什么？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作用域就是变量和函数的可访问范围，控制着变量和函数的可见性与生命周期。使用数学中的函数理解，说白了作用域就是取值范围。        function　 foo(a) {            console.log(a); //2        };        foo(2);上述代码是引擎和作用域的对话。这里注意，&nbsp;LHS和RHS是对于赋值操作( foo()函数的执行也可以理解为赋值操作，相当于是将一个函数赋值给foo，然后执行foo)，即赋值操作左边是否有我们要存放的容器，赋值操作右边是否有我们操作的值即LHS查询：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行foo()时，对foo的查询（是一个函数）&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;执行foo(2)时，对foo内的a进行查询（a是参数）RHS查询：&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 执行foo(2)时，对a的赋值操作&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 执行console.log()时，对log()方法的引用&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 执行console.log(a)时，对a赋值的操作由上述我们可以理解：为什么RHS查询会出现两种错误ReferenceError和TypeError了前者是因为找不到赋值操作，后者是因为找到了，但是进行了不合理的操作，例如这样   let foo = null;        foo(2);&nbsp;因此，我觉得TypeError错误可以理解为RHS查询成功了，但是进行了非法操作。当然这些书中提到了，我这里是梳理了一边逻辑。这是小测验的代码，看完书里的解释，又理解了上面的内容，这个小测验就是小菜一碟        function foo (a){            var b = a;            return a + b;        };        var c = foo( 2 );LHS查询：即赋值操作左边的容器。RHS查询：即赋值操作右边的值。LHS：c=，a=2（foo(2)的隐式操作，就是找有没有a这个参数，因为即便函数有形参也可以不写实参），b=其实我困惑在为什么a=2的赋值操作右边的=2不定义为RHS查询；我这里猜一下，是因为=2不用查，因为2本身就是值，查询的实质是找，变量是存储数据的容器，因此才需要找。RHS：foo这个函数，=a，return a+b的a和b(return相当于是一个赋值操作a+b是赋值操作的值)，本章重要知识：&nbsp; &nbsp; &nbsp; &nbsp; 1.JavaScript是编译语言，其编译发生在代码执行前的几微妙。即编译和执行几乎同步。因此JavaScript会用尽各种办法进行性能性能优化。&nbsp; &nbsp; &nbsp; &nbsp; 2.引擎、编译器、作用域。简单了解作用即可。&nbsp; &nbsp; &nbsp; &nbsp; 3.LHS和RHS查询&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 4.作用域嵌套：即在嵌套的作用域中，引擎的LHS查询会实行冒泡规则查找&nbsp; &nbsp; &nbsp; &nbsp; 5.不成功的LHS查找会自动创建一个全局变量（非严格模式），严格模式下会抛出ReferenceError异常，不成功的RHS查询会抛出ReferenceError异常第2章&nbsp;词法作用域我认为本章的难点：先通俗回答本章的标题：&nbsp; &nbsp; &nbsp; &nbsp; 词法作用域：即是语言给代码的书写提供了一套书写规则，按照这个规则而形成的作用域就是词法作用域，说白了就是代码块的作用范围。例如书写函数时，函数内部的数据，外部一般无法访问，这个函数作用范围就是词法作用域的一部分。&nbsp;在这张图中，这三个作用域气泡就是词法作用域，即是按照代码的书写规则来，形成的代码块的作用范围。作用域气泡严格包含，即只会出现气泡包含，不会出现气泡交叉解释一下书中附录A中提到的动态作用域&nbsp; &nbsp; &nbsp; &nbsp; 1.JavaScript只有词法作用域！（但this机制和动态作用域很像）        function foo() {            console.log(this.a); //2            console.log(a); //2        }        function bar() {            var a = 3;            foo();        }        var a = 2;        bar();&nbsp;这里如果JavaScript是动态作用域，那么输出的将会是3，因为动态作用域会查找调用栈。&nbsp; &nbsp; &nbsp; &nbsp; 2.词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定的。关于eval欺骗词法详解        //eval欺骗词法        function foo(str, a) {            eval(str); //欺骗            console.log(a, b);        }        var b = 2;        foo(\'var b = 3;\', 1)&nbsp;基本上没啥好说的，就是会直接把传入的字符串转换为js代码，即此时的eval(str)完全等价于var b = 3;说一下这个函数的妙用，eval会执行字符串，当我们的到的数据是可以执行的字符串时，那么使用eval还是挺炫的。关于with欺骗词法的详解先说理解，with会关联一个对象，并且with内的变量均会映射到关联对象的同名属性。with内的变量若没有映射到同名属性，则会LHS查询向上冒泡        function foo(obj) {            with(obj) { //会创建作用域气泡                var b = 3; //实际上会被定义在foo函数内                // let c = 6;//会被限制在with内                a = 2; //这个a会直接找obj的属性a                console.log(a); //2                console.log(obj.a); //undefined                console.log(b); //3                console.log(obj.b); //undefined            };            // console.log(a) //ReferenceError            console.log(b); //3            // console.log(c);        };        var o1 = {            a: 3        }        var o2 = {            b: 3        };        foo(o1);        console.log(o1.a); //2        // // console.log(a); //RHS查询，ReferenceError        // foo(o2);        // console.log(o2.a); //undefined        // console.log(o2.b); //undefined        // console.log(a); //2,window.a&nbsp;1.这句话的前半句就是说with会创建一个作用域气泡；后半句就是说传入对象的属性会关联到with作用域气泡内的同名标识符。就如，在第6行代码中a可以直接输出为2；而此时，在代码11行和代码23行，输出a的值就是ReferenceError。就是说with内的赋值操作的规则是：赋值操作优先赋值到传入with内对象的对应属性，当没有对应的属性时，赋值操作会冒泡LHS查询对应的变量容器。因此，当我们在with内书写c=2时，若传入的对象没有c属性，with会冒泡查询；若有c属性时，with会停止查找，赋值到此属性。2.这段话：就是在代码3行，使用var声明变量b后，在with的作用域气泡外，即foo函数的气泡内可以访问变量b，即是此处var声明的变量属于with所在的作用域气泡。当你理解到这里。with的欺骗词法在于，它会给传入对象创建一个作用域气泡，即词法作用域。就是说，在这个气泡内a=2是不可以在外部访问的，而若此对象没有这个属性，a=2可以修改外部作用域气泡的变量。说一下with的妙用，把eval嵌入到with内并给eval传入修改关联with对象属性的代码，就可以动态修改对象的数据了。但不要这样做，会导致性能极度下降。希望读者自行将上述代码放行注释运行查看，有些细节，需要运行代码自我体会。本章重要知识：1.词法作用域就是定义在词法阶段的作用域，即作用域是由书写代码时函数声明的位置决定。2.作用域会在找到第一个匹配的标识符时停止，因此会有“遮蔽效应。3.欺骗词法：eval和with（会创建作用域气泡）4.JavaScript引擎会在编译阶段进行数项的性能优化5.欺骗词法会使得JavaScript引擎无法在编译时对作用域查找进行优化。6.作用域查找始终从运行时所处的最内部作用域开始。第3章 函数作用域和块作用域我认为本章的难点：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.立执行函数的小例子        undefined = true; //企图覆盖undeined        console.log(undefined); //undefined,可见修改不成功        (function IIFE(undefined) {            console.log(undefined) //undefined,            var a;            if (a === undefined) {                console.log(\'Undefined  is  safe  here!\')            }        })(); //没有传入参数这个例子，即是想覆盖默认值，但是实际发现，undefined并不会被覆盖&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.IIFE函数可以倒置代码的执行顺序        var a = 2;        (function IIFE(def) {            def(window);        })(function def(global) {            var a = 3; //会有遮蔽效应            console.log(a); //3            console.log(global.a); //2        });这段代码其实很好理解，即def被当作参数传递给了IIFE，并在IIFE内部执行，两次输出的不同实质是遮蔽效应导致&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本章重要知识：&nbsp; &nbsp; &nbsp; &nbsp; 1.无论标识符声明出现在作用域的何处买这个标识符所代表的标量或函数都将依附于所处作用域的气泡。（这里说的原理，应该就是变量提升和函数优先）&nbsp; &nbsp; &nbsp; &nbsp; 2.每一个函数内部都是一个作用域气泡，基于此，我们可以将代码包裹在函数作用域气泡内，这种基于作用域的隐藏方法即为最小特权原则。        function foo() {            function bar(a) {                i = 3; //修改for循环中所属作用域中的i                for (var i = 0; i &lt; 10; i++) {                    bar(i * 2); //此时造成无限循环了                }            }        }&nbsp;这里就是出现了变量冲突，我们应该让bar函数内部的i成为本地变量。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.很多库为了避免变量冲突，大都是定义一个独特的对象，让每个变量、方法成为变量的属性。&nbsp; &nbsp; &nbsp; &nbsp; 4.具名函数和匿名函数表达式        //注意，因为是表达式，所以结尾需要使用分号        //匿名函数表达式        (function() {            var a = 3;            console.log(a);        });        //具名函数表达式        (function foo() {            var a = 3;            console.log(a);        });&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.立执行函数表达式&nbsp;        //形式一        (function foo(a) {            console.log(a);        }(3));        //形式二        (function foo(a) {            console.log(a);        })(3);&nbsp; &nbsp; &nbsp; &nbsp; 6.JavaScript语言表面上没有块级作用域的相关功能，实际上with（仅关联对象的属性同名标识符具有块级，语言表述能力有限，请自行到上述with解释查看。书中把这种表现形式称为块级，我觉得不够严谨，因为在with内声明的非同名属性标识符实际上是定义在with所在作用域气泡内的）、try/catch的catch均会创建一个块级作用域。try/catch的性能不佳&nbsp; &nbsp; &nbsp; &nbsp; 7.let关键字可以将变量绑定到所在的任意作用域中，即let可以为其声明的变量隐式地劫持了所在的块作用域。第4章&nbsp; 提升我认为本章的难点：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.块内作用域的函数提升机制。JavaScript未来可能会改变这种机制，因此尽量不要在块内声明函数。        // foo(); //TypeError: foo is not a function        var a = true;        console.log(foo); //undefined        if (a) { //实际上被提升到if块内了            function foo() {                console.log(\'a\');            }        } else {            function foo() {                console.log(\'b\');            }        }        console.log(foo);本章重要知识点：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.JavaScript编译器编译前会优先找到所有声明，并用合适的作用域将其关联起来。因此，包括变量和函数在内的所有声明都会在任何代码被执行前优先被处理。        //写的是这        foo();        function foo() {            console.log(a); //undefined            var a = 2;        }        //实际运行的是这        function foo() {            var a;            console.log(a);            a = 2;        }        foo();&nbsp; &nbsp; &nbsp; &nbsp; 2.函数声明和变量声明均会被提升，即函数名和变量名同名时，函数提升会导致忽略同名的变量。就是函数提升的优先级较高。第5章&nbsp; 作用域闭包&nbsp; &nbsp; &nbsp; &nbsp; 此时我真正理解了什么是闭包，才体会到了 启示 ——&nbsp;JavaScript中的闭包无处不在！！！ 这句话的含义。我认为本章的难点：        function foo() {            var a = 2;            function bar() {                console.log(a)            }            return bar;        }        foo()(); //2        var baz = foo(); //2        baz();闭包就是JavaScript引擎阻止了正在被引用函数的垃圾回收，即代码中bar持续被引用，也即是foo的作用域气泡持续被引用。就行例子中，foo函数已经被执行了，foo函数理应会被回收，但是JavaScript引擎阻止了回收。我们通俗的理解闭包，即为函数被封闭在作用域气泡内，函数的调用却在作用域气泡之外。上述，是我试图用书中解释理解闭包，但总觉得过于学术，因此，我的理解：&nbsp; &nbsp; &nbsp; &nbsp; 0.我把函数的执行，理解为函数名是函数执行的开关，函数名()就会打开这个开关，“触发”函数。&nbsp; &nbsp; &nbsp; &nbsp; 1.函数的执行、变量的取值均是一种“触发”；即函数名(),直接引用变量名，这些均是对函数及变量的“触发”。&nbsp; &nbsp; &nbsp; &nbsp; 2.但是函数和变量不同，函数的执行是函数名()，函数名即为变量(我称变量为容器)，仅是存储函数的容器（实际上存放的是函数的指针，即函数的快捷方式），请看下述代码        (function() {            function foo() {                var a = 2;                function bar() {                    console.log(a)                }                return bar;            }            console.log(foo); //函数foo            console.log(window.foo); //undefined            foo = 12;            console.log(foo) //12            console.log(window.foo); //undefined        })();&nbsp;说明foo可以被赋值，且不是window对象的属性，故可以断定foo就是一个变量(容器)，当然，其实学过C语言或者其他语言的都是知道这一点的，我仅是为了更加确定而已。&nbsp; &nbsp; &nbsp; &nbsp; 3.因此，我说函数的“触发“需要两个条件：函数名和()。()会自动找到变量内的函数并执行        //闭包的深度解析        function foo() {            var a = 2;            function bar() {                console.log(a)            }            return bar;        }        foo()(); //2        var baz = foo(); //2        baz();&nbsp;在这段代码中，bar仅仅是一个存放函数的变量，执行函数foo后会返回bar变量。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.现在拉回来，由于JavaScript是词法作用域，函数的执行，其执行的作用域是在函数定义的作用域气泡内。&nbsp; &nbsp; &nbsp; &nbsp; 5.即函数foo是把bar函数的“触发”开关返回到了外面。外面使用()执行了foo内函数bar，接着就是正常词法作用域的操作了。        function setupBot(name, selector) {            $(selector).click(function activator() {                console.log(\'Activating\' + name);            })        }        setupBot(\'Closure Bot 1\', \'#bot_1\')理解到这里，上面这段代码之所以是闭包，原因即是，内部回调函数的执行是由外部的setupBot控制的。&nbsp; &nbsp; &nbsp; &nbsp; 6.解释下循环和闭包        for (var i = 1; i &lt;= 5; i++) {            // var j = i;            setTimeout(function timer() {                console.log(j)            }, i * 1000);        }这里仅有两级作用域，全局作用域(for循环内)和回调函数内的作用作用域，根据词法作用域规则，回调函数作用域会共享全局作用域，故最终都会输出6        for (var i = 1; i &lt;= 5; i++) {            (() =&gt; {                var j = i;                setTimeout(function timer() {                    console.log(j)                }, i * 1000);            })();        }这里使用了立执行函数(ES6语法)，因此，此时有三级作用域，即全局作用域(for内)、立执行函数的作用域、回调函数的作用域。详细解释下：每次迭代会有5个立执行函数作用域同级和5个回调函数作用域同级，且分别是包含关系故每次迭代时定义的 j 变量分别属于5个立执行函数的作用域，就是说没有 j 的进行数据存储的话，回调函数会由词法作用域规则向上冒泡查找i，这样还是输出5个6        for (var i = 1; i &lt;= 5; i++) {            ((j) =&gt; {                setTimeout(function timer() {                    console.log(j)                }, j * 1000);            })(i);        }这个改进之后的代码，事实上说明了，函数的每次执行，参数都会进行一次绑定。和使用let很像        for (let i = 1; i &lt;= 5; i++) {            setTimeout(function timer() {                console.log(i)            }, i * 1000);        }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.模块和闭包连用。模块就是一个封闭函数返回了一个对象(函数本质也是对象)，因此模块内部形成闭包，故可以通过返回的对象对模块内部持续引用，进行操作。        var foo = (function CoolModule(id) {            function change() {                //修改公共API                publicAPI.identify = identify2;            };            function identify1() {                console.log(id);            };            function identify2() {                console.log(id.toUpperCase());            };            var publicAPI = {                change: change,                identify: identify1            };            return publicAPI; //返回模块        })(\'foo module\');        //此时foo对其模块内部持续引用        //故下述方法执行了模块内部的函数        foo.identify();        foo.change();        foo.identify();&nbsp; 理解了闭包之后，理解模块变得轻而易举。上述代码没啥说的，就是模块产生了闭包，然后对模块内部的持续引用，进行的一些操作。8.书中 现代模块机制 的一个代码案例        //现代的模块机制        var MyModules = (function Manager() {            var modules = {};            function define(name, deps, impl) {                for (var i = 0; i &lt; deps.length; i++) {                    deps[i] = modules[deps[i]];                };                modules[name] = impl.apply(impl, deps);            };            function get(name) {                return modules[name];            };            return {                define: define,                get: get,            }        })();        MyModules.define(\'bar\', [], function() {            function heool(who) {                return \'Let me introduce: \' + who;            };            return { //返回的是对象                heool: heool            };        });        MyModules.define(\'foo\', [\'bar\'], function() {            var hungry = \'hippo\';            function awesome() {                console.log(bar.hello(hungry).toUpperCase());            };            return { //返回的是对象                awesome: awesome            };        });        var bar = MyModules.get(\'bar\');        var foo = MyModules.get(\'foo\');        console.log(bar.hello(\'hippo\')); //Let me introduce:hippo        foo.awesome();&nbsp;其实挺好理解的，就是有点绕：&nbsp; &nbsp; &nbsp; &nbsp; 先说defined函数:一个参数name是会给modules添加一个属性，第二个参数deps就是对modules的属性遍历，并且将遍历的东西传入到第三个参数impl(回调函数)，第三个参数也会变成modules的属性。&nbsp; &nbsp; &nbsp; &nbsp; 再说get函数：就是简单的获取moduls的属性这里说一下代码中第一次执行MoModules.define()时传入了一个空数组，显然modules获取不到属性，则下面的impl.apply()传入的deps就是空了；也就是说apply的第二个参数是一个空，apply的第二个参数是传递给原函数的，即是第一次执行的时候，回调函数内没有传值。第二次同理。当然，还是需要自己认真体会代码的。9.关于附录C&nbsp; this词法的一些理解&nbsp; &nbsp; &nbsp; &nbsp; 在setTimeout中this指向了window，官网给出的答案是：由setTimeout()调用的代码运行在与所在函数完全分离的执行环境上在我看来，obj.cool是指向了cool函数，js引擎在执行obj.cool()时，是一种obj修饰的调用；由此foo也指向了cool函数，故此时foo是对cool函数的直接引用，foo()执行时是不加修饰的调用；因此，我认为setTimeout的参数就是相当于foo一样，是对cool函数的不加修饰的调用。        //附录C  this词法        var obj = {            id: \'awesome\',            cool: function coolFn() {                console.log(this.id);                // console.log(this);            }        };        var id = \'not awesome\';        obj.cool(); //awesome        //this的绑定取决于调用位置，故这里是对coolFn函数的直接引用，即直接调用        var foo = obj.cool;        foo(); //not awesome        // 可见这里也是直接引用        setTimeout(obj.cool, 100); //not awesome        // console.log(window.id)本章知识点：&nbsp; &nbsp; &nbsp; &nbsp; 1.基本都是难点，要记得不多，但均需要理解。&nbsp; &nbsp; &nbsp; &nbsp; 2.模块模式的必要条件：&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ①必须由外部的粉笔函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）。&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ②封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。&nbsp; &nbsp; &nbsp; &nbsp; 3.模块文件中的内容会被当做包含在作用域闭包中一样处理。类似于函数闭包模块.第二部分&nbsp; this和对象模型第1章&nbsp; 关于this本章就是讲了一些对this的误区我认为的本章难点：无书中本章知识点：&nbsp; &nbsp; &nbsp; &nbsp; 1.为什么要使用this？this提供了一种更简洁且易于复用的API设计，我们可以通过更改this指向，隐式的“传递”一个对象的引用。&nbsp; &nbsp; &nbsp; &nbsp; 2.this不指向自身。        // 关于this        function foo(num) {            console.log(\'foo: \' + num);            //记录foo被调用的次数            this.count++;        };        foo.count = 0;        var i = null;        for (i = 0; i &lt; 10; i++) {            if (i &gt; 5) {                foo(i);            }        }        console.log(foo.count); //0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.this在任何情况下都不指向函数的词法作用域，作用域存在于JavaScript引擎内部。&nbsp; &nbsp; &nbsp; &nbsp; 4.经典的this错误，它试图跨越边界        var obj = {}        function foo() {            var a = 2;            this.bar();        }        function bar() {            // LHS查询对象的时候貌似会自动创建属性，应该时新改的。            console.log(this.a); //undefined            console.log(obj.a); //undefined        }        // this.foo(); //undefined        //我觉得定义在全局作用域的函数也会成为全局对象的属性        foo();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.this的绑定和函数的声明位置没有任何关系，只取决于函数的调用方式&nbsp;.即this实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。第2章&nbsp; this全面解析本章就是说了this的指向的规则，及怎么修改this指向，我认为的本章难点：&nbsp; &nbsp; &nbsp; &nbsp; 1.书中的MDN的bind实现，最后的部分没看懂      if (!Function.prototype.bind) { //检擦Function的原型是否有bind方法            Function.prototype.bind = function(OThis) { //定义bind方法                if (typeof this !== \'function\') { //检查调用者是否是函数                    //与 ECMAScript 5最接近的                    //内部 IsCallacle 函数                    throw new TypeError( //如果不是函数，则抛出一个错误，这个函数会停止后续代码的执行                        \'Function.prototype.bind - what is trying\' +                        \'to be bound is not callable\'                    );                };                //分割bind函数的参数，slice可以分割arguments这个伪数组，1代表从第2个索引开始分割arguments                var aArgs = Array.prototype.slice.call(arguments, 1),                    fToBind = this, //bind调用者                    fNOP = function() {}, //                    fBound = function() {                        return fTobind.apply(                            (                                this instanceof fNOP //fNOP的原型链是否在this原型链上                                &amp;&amp;                                OThis ? this : OThis //oThis是否存在                            ),                            aArgs.concat(                                Array.prototype.slice.call(arguments)                            )                        );                    };                fNOP.prototype = this.prototype;                fBound.prototype = new fNOP();                return fBound;            }        }&nbsp; &nbsp; &nbsp; &nbsp; 2.书中软绑定源码，我现在还没能完全理解        //软绑定        if (!Function.prototype.softBind) {            Function.prototype.softBind = function(obj) {                var fn = this;                //捕获所欲curried参数                var curried = [].slice.call(arguments, 1);                var bound = function() {                    return fn.apply(                        (!this || this === (window || global)) ?                        obj : this,                        curried.concat.apply(curried, arguments)                    );                };                bound.prototype = Object.create(fn.prototype);                return bound;            }        }        function foo() {            console.log(\'name: \' + this.name);        }        var obj = {                name: \'obj\'            },            obj2 = {                name: \'obj2\'            },            obj3 = {                name: \'obj3\'            };        var fooOBJ = foo.softBind(obj); //绑定到了obj上        fooOBJ(); //name:obj        obj2.foo = foo.softBind(obj);//绑定到obj上        obj2.foo(); //name:obj2，貌似和隐式绑定差不多        fooOBJ.call(obj3); //name:obj3        setTimeout(obj2.foo, 100); //name:obj&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3.箭头函数会捕获调用上级函数的this，且无法修改。箭头函数可以像bind一样确保函数的this被绑定到指定对象，实质是使用词法作用域取代了this机制，内部有类似于var self = this;这句代码&nbsp; &nbsp;        //箭头函数        function foo() {            //返回一个箭头函数            return (a) =&gt; {                //this继承自foo()                console.log(this.a)            }        }        var obj1 = {            a: 2        };        var obj2 = {            a: 3        };        var bar = foo.call(obj1);        bar.call(obj2); //2本章重要知识点：&nbsp; &nbsp; &nbsp; &nbsp; 1.调用位置就是函数在代码中被调用的位置（而不是声明位置）。需要分析调用栈。&nbsp; &nbsp; &nbsp; &nbsp; 2.函数运行在“非严格模式”下，函数会执行默认绑定；但在严格模式下调用函数，则不影响函数的默认绑定 。区分一下运行和调用。默认绑定就是全局函数默认绑定到全局对象上。&nbsp; &nbsp; &nbsp; &nbsp; 3.当函数引用有上下文对象时，隐式绑定规则会把函数调用中的this绑定到这个上下文对象。对象的属性引用链中只有上一层或者说最后一层在调用位置中起作用        function foo() {            console.log(this.a)        }        var obj2 = {            a: 42,            foo: foo        }        var obj1 = {            a: 2,            obj2: obj2        }        obj1.obj2.foo(); //42&nbsp; &nbsp; &nbsp; &nbsp; 3.&nbsp;隐式绑定造成this丢失的实质是对一个函数的直接引用（不带任何修饰的函数调用）&nbsp; &nbsp; &nbsp; &nbsp; 4.回调函数的函数可能会修改this，流行的JavaScript库中事件处理器常会把回调函数的this强制绑定到触发事件的DOM元素上。我是用jQuery发现并没有像后半句所说的那样        window.addEventListener(\'load\', function() {            console.log(this); //window            document.querySelector(\'p\').addEventListener(\'click\', function(e) {                function foo() {                    console.log(this); //window                }                foo();                //这里就是绑定到触发的DOM元素上                console.log(this); //p                console.log(e.target); //p            })        })        $(function() {            console.log(this); //#document,貌似是jQuery的文档对象            $(\'p\').on(\'click\', function(e) {                function foo() {                    console.log(this); //window                }                foo();                console.log(this); //p                console.log(e.target); //p            })        })&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.硬绑定call和apply2。硬绑定就是使用新函数对call和apply语句进行了隔离。        //硬绑定，        function foo() {            console.log(this.a)        }        var obj = {            a: 2,            foo: foo        };        var a = 3;        var bar = function() {            // foo();            return foo.call(obj); //2        };        bar();        setTimeout(bar, 100); //2        //硬绑定的bar不可能再修改它的this。        //上面这句和废话一样，bar现在是一个新函数，这些操作均是对新函数的操作，怎么会修改foo的this        bar.call(window); //2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.new操作符调用的是普通函数，即所有函数均可使用new调用。不存在所谓的”构造函数“，只有对于函数的”构造调用“，new的操作：&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.创建（或者说构造）一个全新的对象&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.这个新对象会被执行[[Prototype]]连接&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3.这个新对象会被绑定到函数调用的this&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4.如果函数没有返回其他对象，那么new表达式的函数调用会自动返回这个新对象&nbsp;        function foo(a) {            this.a = a;        }        var bar = new foo(2);        //返回了一个新对象，因此可以bar.a访问新对象的属性        console.log(bar.a); //2&nbsp; &nbsp; &nbsp; 7.判断this：&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ①函数是否在new中调用(new 绑定)？如果是的话this绑定的是新创建的对象。&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var&nbsp; bar = new foo();&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ②函数是否通过call、apply（显示绑定）或着硬绑定调用?如果是的话，this绑定的是指定的对象。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp; bar&nbsp;= foo.call(obj2)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ③函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this绑定的是那个上下文对象。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var bar =obj1.foo();&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ④如果均不是的话，使用默认绑定。如果严格模式下，就绑定到undefined，否则绑定到全局对象。&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var&nbsp; bar&nbsp; =&nbsp; foo();&nbsp; &nbsp; &nbsp; &nbsp; 8.柯里化：把除了第一个参数（第一个参数用于绑定this）之外的其他参数都传给下层的函数（这种技术称为”部分应用“，是“柯里化”的一种）&nbsp; &nbsp; &nbsp; &nbsp; 9.JavaScript中创建一个空对象最简单的方法都是object.create(null)。这么做不会创建object.prototype这个委托，比{}“更空”。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.对于默认绑定来说，决定this绑定对象的并不是调用位置是否处于严格模式，而是函数体是否处于严格模式。&nbsp; &nbsp; &nbsp; &nbsp; 11.硬绑定会大大降低函数的灵活性，使用硬绑定之后就无法使用隐式绑定或者显示绑定来修改this。第3章&nbsp; 对象有一种常见的说法“JavaScript中万物皆是对象”，这显然是错误的。本章就是讲了对象的一些操作：创建、配置、封印本章难点：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.Symbol.iterator：为每一个对象定义了默认的迭代器。该迭代器可以被 for-of&nbsp;循环使用。for-of会找内置的@@iterator对象并调用next()方法来遍历数据        //自定义对象迭代器        var myObject = {            a: 2,            b: 3        };        Object.defineProperty(myObject, Symbol.iterator, {                enumerable: false,                writable: false,                configurable: true,                value: function() {                    var o = this;                    var idx = 0;                    var ks = Object.keys(o);                    return {                        next: function() {                            return {                                value: o[ks[idx++]],                                done: (idx &gt; ks.length)                            };                        }                    };                }            })            //手动遍历myObject        var it = myObject[Symbol.iterator]();        console.log(it.next()); //{value:2,done:false}        console.log(it.next()); //{value:3,done:false}        console.log(it.next()); //{value:undefined,done:true}        //for-of遍历        for (var v of myObject) {            console.log(v)        }; //2,3&nbsp;代码的意思就是定义了一个Symbol.iterator属性，这个属性的value是个函数，函数内部有各种操作。文字表达起来有点费劲，可以尝试运行代码自行体会本章知识点：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.JavaScript的六种主要类型：string，number，boolean，null，undefined，object。&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typeof&nbsp; null;之所以返回Object，是因为JavaScript中二进制前三位均为0，就会被判定为object类型，而null的二进制表示全为0，自然被判定为object了&nbsp; &nbsp; &nbsp; &nbsp; 2.内置对象：String，Number，Boolean，Object，Function，Array，Date，RegExp，Error。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.JavaScript会自动将字符串，数字等使用方法时，会转换为内置对象，如‘I am string’，实际上会进行new String(‘I am string’)&nbsp; &nbsp; &nbsp; &nbsp; 4.在对象中，属性名永远是字符串，如果你使用string（字面量，字符串的存储是固定的）以外的其他值作为属性名，那它首先会被转换为一个字符串；&nbsp; &nbsp; &nbsp; &nbsp; 5.数组也是对象，因此可以给数组添加属性，但是如果试图给数组添加一个类数字属性，进行键访问的时候，此属性会变成一个数值下标        var myArray = [\'foo\', \'turnip\', 43];        myArray[\'3\'] = \'kkk\';        myArray.length; //4        myArray[3]; //43&nbsp; &nbsp; &nbsp; &nbsp; 6.Object.defineProperty官方描述：Object.defineProperty。该方法可以配置对象        \'use strict\' //修改只读属性，会报错        var myObject = {};        Object.defineProperty(myObject, \'a\', {            value: 2,            writeable: false, //不可写,只读            configurable: true, //可配置的            enumerable: true //可枚举        });        myObject.a = 3;        console.log(myObject.a); //2&nbsp; &nbsp; &nbsp; &nbsp; 7.结合 writeable:false和configurable:false 就可以创建一个真正的常量属性(不可修改、重定义或删除)        var myObject = {};        Object.defineProperty(myObject, \'FAVORITE_NUMBER\', {            value: 42,            writable: false,            configurable: false        })&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;8.Object.preventExtensions官方解释：Object.preventExtensions。该方法可以让一个对象变的不可扩展，也就是永远不能再添加新的属性。        var myObject = {            a: 2        };        Object.preventExtensions(myObject);        myObject.b = 3;        console.log(myObject.b); //undefined&nbsp; &nbsp; &nbsp; &nbsp; 9.Object.seal()官方解释：Object.seal。该方法封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置、不可删除。当前属性的值只要原来是可写的就可以改变。&nbsp; &nbsp; &nbsp; &nbsp; 10.Object.freeze()官方解释：Object.freeze()。这个方法是可以应用在对象上的级别对高的不可变性。&nbsp; &nbsp;11.getter和setter均是一个隐藏函数，前者获取属性时调用，后者设置属性时调用。        var myObject = {            //给a定义一个getter            get a() {                return this._a_;            },            set a(val) {                this._a_ = val * 2;            }        }        myObject.a = 2;        console.log(myObject.a);//4        console.log(myObject._a_); //4，创建了一个属性&nbsp; &nbsp; &nbsp; &nbsp; 11可枚举 就相当于 可以出现在对象属性的遍历中。for-in会静默，但是for循环可以。&nbsp; &nbsp; &nbsp; &nbsp; propertyIsEnumerable()会检查给定的属性名是否直接存在于对象中（而不是原型链上）并且满足enumerable：true&nbsp; &nbsp; &nbsp; &nbsp; Object.keys()会返回一个数组，包含所有可枚举的属性，Object,getOwnpropertyNames()会返回一个数组，包含所有属性，无论他们是否可枚举；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object.prototype.hasOwnProperty和in的区别在于是否查找[[Prototype]]链&nbsp; &nbsp; &nbsp; &nbsp; object.keys()和Object.getOwnPropertyNames()都只会查找对象直接包含的属性        var myObject = {};        Object.defineProperty(myObject, \'a\',            //让a像普通属性一样可以枚举            {                enumerable: true,                value: 2            });        Object.defineProperty(myObject, \'b\',            //让a像普通属性一样可以枚举            {                enumerable: false,                value: 2            });        console.log(myObject.b); //3        console.log((\'b\' in myObject)); //true        console.log(myObject.hasOwnProperty(\'b\')); //true        for (var key in myObject) {            console.log(key, myObject[key]);        }; //\'a\' 2        console.log(myObject.propertyIsEnumerable(\'a\')); //true        console.log(myObject.propertyIsEnumerable(\'b\')); //false        console.log(Object.keys(myObject)); //[\'a\']        console.log(Object.getOwnPropertyNames(myObject)); //[\'a\',\'b\']第4章&nbsp; 混合对象 “类”只要理解了this指向和对象，这一章的内容理解起来很容易，都是一些概念而已。本章难点：&nbsp; &nbsp; &nbsp; &nbsp; 1.多态就是任何方法均可以引用继承层次中高层的方法，及继承使得方法可以在多类中映射。&nbsp; &nbsp; &nbsp; &nbsp; 2.显示多态就是把显示的将父类的方法引入子类，但此时方法显示绑定的对象是子类本章知识点：&nbsp; &nbsp; &nbsp; &nbsp; 1.类/继承描述了一种代码的住址结构——一种在软件中对真实世界中问题领域的建模方法，面向对象编程强调的是数据和操作数据的行为本质上是互相关联的。&nbsp; &nbsp; &nbsp; &nbsp; 2.JavaScript中并没有类，JavaScript只是提供了一些近似类的语法，因此JavaScript的类是一种设计模式(类本身就是一种设计模式)。如ES6的class&nbsp; &nbsp; &nbsp; &nbsp; 3.类实例是由一个特殊的类方法构造的，这个方法名通常和类同名，被称为构造函数。&nbsp; &nbsp; &nbsp; &nbsp; 4.类的继承其实就是复制第5章&nbsp; 原型原型的实质就是对象之间的关联关系。本章难点：&nbsp; &nbsp; &nbsp; &nbsp; 1.原型的本质就是一种关联关系，原型链就是关联树，即JavaScript引擎会查找原型链        var anotherObject = {            a: 2        };        //创建一个关联到anotherObject的对象        var myObject = Object.create(anotherObject);        //注意此时myObject.a并不存在，但是JavaScript引擎会在原型链上查找该属性        console.log(myObject.a); //2&nbsp; &nbsp; &nbsp; &nbsp; 2.隐式屏蔽        var anotherObject = {            a: 2        };        var myObject = Object.create(anotherObject);        console.log(anotherObject.a); //2        console.log(myObject.a); //2        console.log(anotherObject.hasOwnProperty(\'a\')); //true        console.log(myObject.hasOwnProperty(\'a\')); //false        console.log(anotherObject);        console.log(myObject); //属于anotherObject下一级        myObject.a++; //myObject.a= myObject.a + 1        console.log(anotherObject.a); //2        console.log(myObject.a); //3        console.log(myObject.hasOwnProperty(\'a\')); //true&nbsp; &nbsp; &nbsp; &nbsp; 3.new的关联，new的操作，就是创建了一个关联到其他对象的新对象。实际上我们并没有复制“类“，只是让他们关联而已        function Foo() {}        var a = new Foo();        //new操作后，都会被关联到Foo.prototype对象上        console.log(Object.getPrototypeOf(a) === Foo.prototype); //true本章知识点：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.使用for-in&nbsp;遍历对象时原理和查找[[Prototype]]链类似，任何可以通过原型链访问到的属性都会被枚举。使用in操作符来检查属性在对象中是否存在时，同样会查找对象的整条原型链。&nbsp; &nbsp; &nbsp; &nbsp; 2.所有普通的[[Prototype]]链最终都会指向内置的Object.prototype。&nbsp; &nbsp; &nbsp; &nbsp; 3.函数不是构造函数，但当且仅当使用new时，函数调用会变成”构造函数调用“。&nbsp; &nbsp; &nbsp; &nbsp; 4.Object.create()会创建一个新对象，并把它关联到我们指定的对象上        //兼容的Object.create        if (!Object.create) {            Object.create = function(o) {                function F() {}; //声明空函数                F.prototype = o;                return new F();            }        }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5.内部委托。避免明明当前对象没有这个属性，但是却神奇的可以调用。也使得API设计更加清晰        var anotherObject = {            cool: function() {                console.log(\'cool!\');            }        }        var myObject = Object.create(anotherObject);        myObject.doCool = function() {            this.cool(); //内部委托        }        myObject.doCool();第6章&nbsp; 行为委托这一章没什么可说的，就是对委托这种设计模式的讲解，理解了this机制、对象、原型之后，书中的代码也并没有什么难点。知识回顾：&nbsp; &nbsp; &nbsp; &nbsp; 1.如果在第一个对象上没有找到需要的属性或者方法引用，JavaScript引擎会继续在[[Prototype]]关联的对象上进行查找。&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 2.JavaScript的原型链机制的本质就是对象与对象之间的关联关系。本章难点：&nbsp; &nbsp; &nbsp; &nbsp; 1.类理论和委托理论的对比：        //类理论(伪代码)        class Task {            id;            //函数Task()            Task(ID) {                id = ID;            }            outputTask() {                output(id);            }        };        class XYZ inherits Task {            label;            //构造函数XYZ            XYZ(ID, Label) {                super(ID);                label = Label;            }            outputTask() {                super();                output(label);            }        };        class ABC inherits Task {            //...        };        //委托理论        Task = {            setID: function(ID) {                this.id = ID;            },            output: function() {                console.log(this.id)            }        };        // 让XYZ委托给Task        XYZ = Object.create(Task);        XYZ.prepareTask = function(ID,Label){            this.setID(ID);            this.label = Label;        }        XYZ.outputTaskDetails = function(){            this.outputID();            console.log(this.label);        };        //ABC = Object.create(Task);        //ABC ... = ...可以看出，类理论：当实例化子类时，子类的实例会复制父类和子类的行为&nbsp;。&nbsp;可参考java类原理&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 委托理论：”子类“(对象)通过[[Prototype]]委托给了”父类“，当调用子类中没有的方法时，会通过委托关系查找关联的对象，又由于调用位置触发this的隐式绑定规则，故this的绑定仍是”子类“，而这正是我们想要的结果。由此看来委托的设计模式更加简洁。&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;本章知识点：&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 无','JavaScript','/page3','2021-08-06 21:09:03','32398','0','7','0','Windows','Edge',1),(4,'./T_Image/articleImg/hzw2.jpeg','第四篇--浅析JavaScript的this绑定','<h1 style=\"text-align:center;\" id=\"dre35\">第四篇--浅析JavaScript的this绑定</h1><p>JavaScript的this指向有四种绑定规则，即：</p><p>1.默认绑定</p><p>2.隐式绑定</p><p>3.显示绑定</p><p>4.new调用绑定</p><p style=\"padding-left:2em;\"><strong><font color=\"#c24f4a\">默认绑定：即全局函数的this默认绑定到window</font></strong></p><p>\n</p><pre><code>    var a = 3;//var会连接到window对象\n    let foo = function () {\n      console.log(this.a);\n    }\n    foo();//3</code></pre><p>\n\n\n\n\n\n\n\n\n\n\n\n\n<img src=\"data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==\"/></p><p style=\"padding-left:2em;\"><strong><font color=\"#c24f4a\">隐式绑定：即函数在上下文对象内则绑定到上下文对象上。下转隐式丢失对比理解</font></strong></p><p>\n</p><pre><code>    var a = 3;\n    let obj = {\n      a: 2,\n      foo() {\n        console.log(this.a);\n      }\n    };\n    obj.foo();//2\n    // 或\n    function foo() {\n      console.log(this.a);\n    };\n    let obj = {\n      a: 2,\n      foo: foo\n    };\n    obj.foo();//2</code></pre><p>\n\n\n\n\n<img src=\"data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==\"/></p><p><strong>提一嘴隐式丢失：官方解释bar是对foo不加修饰的调用，因此丢失了obj的绑定。</strong></p><p>我的理解就是，obj.foo在执行时，是通过obj对象查询到foo并进行了调用；而bar是将foo的指针取了出来，bar得到了foo的指针，因此bar()等同于foo();</p><p>\n</p><pre><code>    var a = 3;\n    function foo() {\n      console.log(this.a);\n    };\n    let obj = {\n      a: 2,\n      foo: foo\n    };\n    obj.foo();//2\n    let bar = obj.foo;\n    bar();//3,丢失了obj</code></pre><p>\n\n\n\n\n\n\n<img src=\"data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==\"/></p><p style=\"padding-left:2em;\"><strong><font color=\"#c24f4a\">显示绑定：即通过call、apply方法显示绑定this。</font></strong></p><p>\n</p><pre><code>    var a = 3;\n    function foo() {\n      console.log(this.a);\n    }\n    let obj = {\n      a: 2\n    }\n    foo.call(obj);//2\n    foo.apply(obj);//2</code></pre><p>\n\n\n\n\n<img src=\"data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==\"/></p><p>显示绑定没有解决隐式丢失问题，即foo的绑定还是丢失了。我们需要的是具有foo功能的函数，但是这个函数已经硬硬的绑定到了我们所给的对象上了。</p><p><strong>显示绑定之硬绑定：硬硬的的绑定到我们所给的对象上，实际上就是多包裹了一层函数</strong></p><p>\n</p><pre><code>    function foo() {\n      console.log(this.a);\n    }\n    var obj = {\n      a: 2\n    }\n    var bar = function () {\n      foo.call(obj);\n    }\n    bar();//2\n    bar.call(window);//2</code></pre><p>\n\n\n\n\n\n\n<img src=\"data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==\"/></p><p>bind的实现原理有部分类似于此</p><p style=\"padding-left:2em;\"><strong><font color=\"#c24f4a\">new调用绑定:构造调用，构造调用的函数会出现4种变化</font></strong></p><p>①创建（构造）一个全新的对象</p><p>②这个对象会被直行[[Prototype]]链接</p><p>③这个新对象会被绑定到函数调用的this</p><p>④如果函数没有返回其他对象，则new表达式中的函数调用会自动返回这个新对象</p><p>明确一点，new不是实例化类，而是调用一个新函数，只是和普通调用不同，这里是构造调用，详解见官网</p><p>\n</p><pre><code>    function foo() {\n      this.a = a;\n    }\n    //即此时new调用会创建一个新对象，并返回，即此时bar就是new调用所建的新对象了\n    var bar = new foo(2);\n    console.log(bar.a);//2</code></pre><p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<img src=\"data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==\"/></p><p><strong><font color=\"#c24f4a\">四中绑定的优先级：new &gt;&nbsp;显示 &gt; 隐式 &gt;&nbsp;默认绑定</font></strong></p><p>\n\n\n<br/></p>','JavaScript的this指向有四种绑定规则，即：1.默认绑定2.隐式绑定3.显示绑定4.new调用绑定默认绑定：即全局函数的this默认绑定到window隐式绑定：即函数在上下文对象内则绑定到上下文对象上。下转隐式丢失对比理解提一嘴隐式丢失：官方解释bar是对foo不加修饰的调用，因此丢失了obj的绑定。我的理解就是，obj.foo在执行时，是通过obj对象查询到foo并进行了调用；而bar是将foo的指针取了出来，bar得到了foo的指针，因此bar()等同于foo();显示绑定：即通过call、apply方法显示绑定this。显示绑定没有解决隐式丢失问题，即foo的绑定还是丢失了。我们需要的是具有foo功能的函数，但是这个函数已经硬硬的绑定到了我们所给的对象上了。显示绑定之硬绑定：硬硬的的绑定到我们所给的对象上，实际上就是多包裹了一层函数bind的实现原理有部分类似于此new调用绑定:构造调用，构造调用的函数会出现4种变化①创建（构造）一个全新的对象②这个对象会被直行[[Prototype]]链接③这个新对象会被绑定到函数调用的this④如果函数没有返回其他对象，则new表达式中的函数调用会自动返回这个新对象明确一点，new不是实例化类，而是调用一个新函数，只是和普通调用不同，这里是构造调用，详解见官网四中绑定的优先级：new &gt;&nbsp;显示 &gt; 隐式 &gt;&nbsp;默认绑定','JavaScript','/page4','2021-08-09 20:36:05','637','0','61','0','Windows','Edge',1),(5,'./T_Image/articleImg/default.jpeg','第五篇--浅析javascript中的混合对象“类”','<p style=\"text-align:center;\"><b><span style=\"font-size: 32px;\">浅析JavaScript中的混合对象“类”</span></b></p><p><strong>&nbsp;这里浅析的是《你不知道的JavaScript 上卷》中的混合对象“类”</strong></p><p>类就是一个解决问题的蓝图，实例化类就是把蓝图构建出来。</p><p><strong>构造函数</strong>：类中均会有一个构造函数，构造函数的作用就是，当实例化类时，会调用这个函数，可以理解为类的入口。</p><p><strong>类的继承</strong>：即子类会继承父类的行为。</p><p><strong>多态</strong>：即类继承之后的引用，会根据类的实例化来决定，就是当父类和子类定义相同的方法时，对于方法的使用取决于实例的类是哪个。多态并非是子类和父类有关联，而是子类得到了父类的副本，即类的继承就是复制。</p><p><strong>多重继承</strong>：子类可以继承多个父类。</p><p>JavaScript中只有对象，并不存在实例化类。</p><p><strong>显示混入</strong>：即是直接显示的进行对象复制。</p><p>\n</p><p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n</p><pre><code class=\"JavaScript\">    <span class=\"hljs-comment\">//相当于实现实例化类的函数，实际上就是一种复制</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">mixin</span><span class=\"hljs-params\">(sourceObj, targetObj)</span> {</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> key <span class=\"hljs-keyword\">in</span> sourceObj) {\n        <span class=\"hljs-comment\">//对不存在的情况进行复制</span>\n        <span class=\"hljs-keyword\">if</span> (!key <span class=\"hljs-keyword\">in</span> targetObj) {\n          targetObj[key] = sourceObj[key];\n        }\n      }\n      <span class=\"hljs-keyword\">return</span> targetObj;\n    };\n    <span class=\"hljs-keyword\">var</span> Vehicle = {\n      engines: <span class=\"hljs-number\">1</span>,\n      ignition: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">()</span> {</span>\n        console.log(<span class=\"hljs-string\">\'Turning on my engine.\'</span>);\n      },\n      drive: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">()</span> {</span>\n        <span class=\"hljs-keyword\">this</span>.ignition();\n        console.log(<span class=\"hljs-string\">\'Steering and moving forward!\'</span>);\n      }\n    };\n    <span class=\"hljs-keyword\">var</span> Car = mixin(Vehicle, {\n      wheels: <span class=\"hljs-number\">4</span>,\n      drive: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">()</span> {</span>\n        Vehicle.drive.call(<span class=\"hljs-keyword\">this</span>);\n        console.log(<span class=\"hljs-string\">\'Rolling on all\'</span> + <span class=\"hljs-keyword\">this</span>.wheels + <span class=\"hljs-string\">\'Wheels!\'</span>)\n      }\n    })</code></pre><p>混合复制：即先把父类复制进一个空对象A内从而得到子类（对象B），再把新内容传入子类（对象B）</p><p>寄生继承：即直接在函数中new父类得到对象A，然后对A进行重写并返回。</p><p><strong>隐式混入：利用显示的this指向，将this指向到子类的上下文。</strong></p><p>\n</p><p>\n\n\n\n\n\n\n\n\n<img src=\"data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==\"/></p><pre><code class=\"JavaScript\">    <span class=\"hljs-keyword\">var</span> something = {\n      cool: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">()</span> {</span>\n        <span class=\"hljs-keyword\">this</span>.greeting = <span class=\"hljs-string\">\'Hello World!\'</span>;\n        <span class=\"hljs-keyword\">this</span>.count = <span class=\"hljs-keyword\">this</span>.count ? <span class=\"hljs-keyword\">this</span>.count + <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">1</span>;\n      }\n    };\n    something.coll();\n    something.greeting;<span class=\"hljs-comment\">//Hello World!</span>\n    something.count;<span class=\"hljs-comment\">//1</span>\n    <span class=\"hljs-keyword\">var</span> Another = {\n      cool: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">()</span> {</span>\n        <span class=\"hljs-comment\">// 隐式将this指向Another，这里cool的this是Another，即显示将something.cool的this指向了Another</span>\n        something.cool.call(<span class=\"hljs-keyword\">this</span>);\n      }\n    }\n    Another.cool();\n    Another.greeting;<span class=\"hljs-comment\">//Hello World!</span>\n    Another.count;<span class=\"hljs-comment\">//1(非共享的something)</span></code></pre><p><br/>\n</p><p>\n\n\n<br/></p>','浅析JavaScript中的混合对象“类”&nbsp;这里浅析的是《你不知道的JavaScript 上卷》中的混合对象“类”类就是一个解决问题的蓝图，实例化类就是把蓝图构建出来。构造函数：类中均会有一个构造函数，构造函数的作用就是，当实例化类时，会调用这个函数，可以理解为类的入口。类的继承：即子类会继承父类的行为。多态：即类继承之后的引用，会根据类的实例化来决定，就是当父类和子类定义相同的方法时，对于方法的使用取决于实例的类是哪个。多态并非是子类和父类有关联，而是子类得到了父类的副本，即类的继承就是复制。多重继承：子类可以继承多个父类。JavaScript中只有对象，并不存在实例化类。显示混入：即是直接显示的进行对象复制。    //相当于实现实例化类的函数，实际上就是一种复制function mixin(sourceObj, targetObj) {for (var key in//对不存在的情况进行复制if (!key inreturnvar1function () {\'Turning on my engine.\'function () {this\'Steering and moving forward!\'var4function () {this\'Rolling on all\' + this.wheels + \'Wheels!\'混合复制：即先把父类复制进一个空对象A内从而得到子类（对象B），再把新内容传入子类（对象B）寄生继承：即直接在函数中new父类得到对象A，然后对A进行重写并返回。隐式混入：利用显示的this指向，将this指向到子类的上下文。    varfunction () {this.greeting = \'Hello World!\'this.count = this.count ? this.count + 1 : 1//Hello World!//1varfunction () {// 隐式将this指向Another，这里cool的this是Another，即显示将something.cool的this指向了Anotherthis//Hello World!//1(非共享的something)','JavaScript','/page5','2021-08-13 15:09:09','925','0','109','0','Windows','Edge',1),(6,'./T_Image/articleImg/hzw2.jpeg','第六篇--关于本网站的未来','<h1 id=\"7p0ku\" style=\"text-align:center;\">关于本网站的未来</h1><p>&nbsp; &nbsp; &nbsp; &nbsp; 由于要开始备考专升本了，而我想要的是全省第一！但是我想要的也并非全是要应试，我会再未来一年好好学习高数和英语，这也正是算法和编程的基本功，我要好好对待，暑假这些天的学习，让我对编程也有了新的认识，以前总以为要深入精学一门语言，现在看来，其实语言仅仅是工具，只需要会一些比较深入的就行，很多东西都可以看文档写出来，真正需要动脑的是算法、编程的思想。这些天在学习一些比较深入的东西时，总觉得有些吃力，总结来看都是需要很强的数学思维。也接触了很多编程的思想，例如声明式编程、命令式编程、函数式编程等。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=\"#c24f4a\" style=\"background-color: rgb(238, 236, 224);\">网</font><font color=\"#c24f4a\" style=\"background-color: rgb(238, 236, 224);\">站的未来不会有太大的更新了，因为除了升本，我还有计算机二级要考，还要在高数之余，试着学学算法。网站也没基本用不到什么了，本身就是一个写作和尝试自己技术的地方。未来学校若让写毕业设计的话，我会抽时间把网站的留言吧功能和手机版写好。</font></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 若有幸到达本科，我会将后台系统完善。目前网站的后台仅仅有个文本编辑器，着实有些寒酸了。<br/></p><p data-we-empty-p=\"\" style=\"text-align:right;\">作者：turnip</p><p data-we-empty-p=\"\" style=\"text-align:right;\">写于2021.8.22</p>','由于要开始备考专升本了，而我想要的是全省第一！但是我想要的也并非全是要应试，我会再未来一年好好学习高数和英语，这也正是算法和编程的基本功，我要好好对待，暑假这些天的学习，让我对编程也有了新的认识，以前总以为要深入精学一门语言，现在看来，其实语言仅仅是工具，只需要会一些比较深入的就行，很多东西都可以看文档写出来，真正需要动脑的是算法、编程的思想。这些天在学习一些比较深入的东西时，总觉得有些吃力，总结来看都是需要很强的数学思维。也解除了很多编程的思想，例如声明式编程、命令式编程、函数式编程等。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;网站的未来不会有太大的更新了，因为除了升本，我还有计算机二级要考，还要在高数之余，试着学学算法。网站也没基本用不到什么了，本身就是一个写作和尝试自己技术的地方。未来学校若让写毕业设计的话，我会抽时间把网站的留言吧功能和手机版写好。&nbsp; &nbsp; &nbsp; &nbsp; 若有幸到达本科，我会将后台系统完善。目前网站的后台仅仅有个文本编辑器，着实有些寒酸了。作者：turnip写于2021.8.22','关于网站','/page6','2021-08-22 23:09:15','537','0','233','0','Windows','Edge',1);

/*Table structure for table `t_friend` */

DROP TABLE IF EXISTS `t_friend`;

CREATE TABLE `t_friend` (
  `t_id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT 'id',
  `t_name` varchar(20) DEFAULT NULL COMMENT '网站名',
  `t_link` varchar(100) DEFAULT NULL COMMENT '网站地址',
  `t_describe` varchar(100) DEFAULT NULL COMMENT '网站描述',
  `t_headImg` varchar(255) DEFAULT NULL COMMENT '网站头像',
  `t_default` varchar(255) DEFAULT './T_Image/Turnip.jpg' COMMENT '默认头像',
  PRIMARY KEY (`t_id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;

/*Data for the table `t_friend` */

insert  into `t_friend`(`t_id`,`t_name`,`t_link`,`t_describe`,`t_headImg`,`t_default`) values (1,'萝卜','http://turnip.ren/','不到最后，决不放弃。','0','./T_Image/Turnip.jpg'),(2,'Turnip起始页','http://turnip.ren','Never give up until the end','http://turnip.ren/image/turnip.jpg','./T_Image/Turnip.jpg');

/*Table structure for table `t_friend_copy` */

DROP TABLE IF EXISTS `t_friend_copy`;

CREATE TABLE `t_friend_copy` (
  `t_id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT 'id',
  `t_name` varchar(20) DEFAULT NULL COMMENT '网站名',
  `t_link` varchar(100) DEFAULT NULL COMMENT '网站地址',
  `t_describe` varchar(100) DEFAULT NULL COMMENT '网站描述',
  `t_headImg` varchar(255) DEFAULT NULL COMMENT '网站头像',
  `t_default` varchar(255) DEFAULT './T_Image/Turnip.jpg' COMMENT '默认头像',
  PRIMARY KEY (`t_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

/*Data for the table `t_friend_copy` */

/*Table structure for table `t_message` */

DROP TABLE IF EXISTS `t_message`;

CREATE TABLE `t_message` (
  `t_id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '唯一标识',
  `t_name` varchar(20) NOT NULL COMMENT '名字',
  `t_email` varchar(50) NOT NULL COMMENT '邮箱',
  `t_text` text NOT NULL COMMENT '评论内容',
  `t_date` varchar(50) NOT NULL COMMENT '评论时间',
  `t_writingPlatform` varchar(20) NOT NULL COMMENT '平台',
  `t_browser` varchar(20) NOT NULL COMMENT '浏览器',
  PRIMARY KEY (`t_id`)
) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8;

/*Data for the table `t_message` */

insert  into `t_message`(`t_id`,`t_name`,`t_email`,`t_text`,`t_date`,`t_writingPlatform`,`t_browser`) values (6,'Turnip','2276157075@qq.com','有问题可以在留言区给我留言。','2021/10/7 下午2:54:05','Windows','Edge'),(7,'薯片','3216378433@qq.com','我来了','2021/10/13 下午12:11:12','Windows','Edge'),(8,'萝卜','2276157075@qq.com','俺来了。','2021/11/24 下午5:11:26','Android','Chrome'),(9,'辣条','2276157075@qq.com','来看看','2022/5/16 下午11:51:55','Android','Chrome'),(10,'刘欢','2276157075@qq.com','快高考了，快点学习。','2022/6/3 下午8:10:17','Android','MIUI Browser');

/*Table structure for table `t_superadmin` */

DROP TABLE IF EXISTS `t_superadmin`;

CREATE TABLE `t_superadmin` (
  `t_id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT 'id',
  `t_email` varchar(20) NOT NULL COMMENT '邮箱',
  `t_password` varchar(20) NOT NULL COMMENT '密码',
  `t_grade` varchar(10) DEFAULT NULL COMMENT '等级',
  `t_name` varchar(10) DEFAULT NULL COMMENT '姓名',
  `t_sex` enum('男','女','外星人') DEFAULT '男' COMMENT '性别',
  `t_age` int(5) unsigned DEFAULT NULL COMMENT '年龄',
  `t_tel` varchar(30) NOT NULL COMMENT '手机号',
  `t_hobby` tinytext COMMENT '爱好',
  `t_job` varchar(20) DEFAULT NULL COMMENT '职业',
  `t_date` datetime NOT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '时间',
  `t_visit` varchar(255) DEFAULT '0' COMMENT '访问',
  PRIMARY KEY (`t_id`),
  UNIQUE KEY `t_id` (`t_id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;

/*Data for the table `t_superadmin` */

insert  into `t_superadmin`(`t_id`,`t_email`,`t_password`,`t_grade`,`t_name`,`t_sex`,`t_age`,`t_tel`,`t_hobby`,`t_job`,`t_date`,`t_visit`) values (1,'2276157075@qq.com','turnip','超级管理员','唐伟康','男',20,'17633505860','数学，编程','学生','2022-08-25 05:38:03','25429');

/*Table structure for table `t_superadmin_copy1` */

DROP TABLE IF EXISTS `t_superadmin_copy1`;

CREATE TABLE `t_superadmin_copy1` (
  `t_id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT 'id',
  `t_email` varchar(20) NOT NULL COMMENT '邮箱',
  `t_password` varchar(20) NOT NULL COMMENT '密码',
  `t_grade` varchar(10) DEFAULT NULL COMMENT '等级',
  `t_name` varchar(10) DEFAULT NULL COMMENT '姓名',
  `t_sex` enum('男','女','外星人') DEFAULT '男' COMMENT '性别',
  `t_age` int(5) unsigned DEFAULT NULL COMMENT '年龄',
  `t_tel` varchar(30) NOT NULL COMMENT '手机号',
  `t_hobby` tinytext COMMENT '爱好',
  `t_job` varchar(20) DEFAULT NULL COMMENT '职业',
  `t_date` datetime NOT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '时间',
  PRIMARY KEY (`t_id`),
  UNIQUE KEY `t_id` (`t_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

/*Data for the table `t_superadmin_copy1` */

/*Table structure for table `tel_turnip_user` */

DROP TABLE IF EXISTS `tel_turnip_user`;

CREATE TABLE `tel_turnip_user` (
  `col_ID` int(11) NOT NULL AUTO_INCREMENT,
  `col_Name` varchar(255) DEFAULT NULL,
  `col_Pass` varchar(255) DEFAULT NULL,
  `col_sex` varchar(255) DEFAULT NULL,
  `col_tel` varchar(255) DEFAULT NULL,
  `col_email` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`col_ID`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;

/*Data for the table `tel_turnip_user` */

insert  into `tel_turnip_user`(`col_ID`,`col_Name`,`col_Pass`,`col_sex`,`col_tel`,`col_email`) values (1,'turnip','kang','男','17633505860','2276157075@qq.com'),(2,'kang','kang',NULL,NULL,'2276157075@qq.com'),(3,'李远哲','123',NULL,NULL,'3111328706@qq.com'),(4,'唐伟涛','123456',NULL,NULL,'2276157075@qq.com');

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
